<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/BrighterCommand/Paramore.Brighter">View the Project on GitHub <small>BrighterCommand/Paramore.Brighter</small></a></p>
        <ul>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="../index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="ImplementingAHandler.html">Next</a></p>
        <p><a href="Implementing%20Ports%20and%20Adapters.html">Prev</a></p>
    </header>
    <section>
        <h1>Brighter</h1>
        <h2>Command</h2>
        <p>The <strong>Command</strong> design pattern encapsulates a request as an object, allowing reuse, queuing or logging of requests, or undoable operations. It also serves to decouple the
            implementation of the request from the requestor. The caller of a Command object does not need to understand how the Command is implemented, only that the Command exists.
            When the caller and the implementer are decoupled it becomes easy to replace or refactor the implementation of the request, without impacting the caller - our system is
            more modifiable. Our ability to test the Command in isolation of the caller - allows us to implement the ports and adapters model easily - we can instantiate the Command,
            provide 'fake' parameters to it and confirm the results. We can also use the command from multiple callers, although this is not a differentiator from the service class approach.
        </p>
        <img src="images/CommandClassDiagram.png" alt="Command Class Diagram">
        <p><strong>Command</strong> - Declares an interface for executing an operation.</p>
        <p><strong>ConcreteCommand</strong> –Defines a binding between a Receiver object and an action. Implements Execute by invoking the corresponding operation(s) on Receiver.</p>
        <p><strong>Client</strong> – creates a ConcreteCommand object and sets its receiver.</p>
        <p><strong>Invoker</strong> - asks the command to carry out the request.</p>
        <img src="images/CommandSequence.png" alt="Command Sequence Diagram">
        <p>An <strong>Invoker</strong> object knows about the <strong>Concrete Command</strong> object. The Invoker issues a request by calling Execute on the <strong>Command</strong>. When commands are un-doable, the Command stores
            state for undoing the command prior to invoking Execute.The Command object invokes operations on its <strong>Receiver</strong> to carry out the request
        </p>
        <p>In addition we can structure a system transactionally using Commands. A Command is a transactional boundary. Because a Command is a transactional boundary,
            when using the <a href="http://en.wikipedia.org/wiki/Domain-driven_design"><em>Domain Driven Design</em></a> technique of an aggregate there is a natural affinity between the Command, which
            operates on a transactional boundary and the <em>Aggregate</em> which is a transactional boundary within the domain model. The Aggregate is the Receiver stereotype within the Command Design pattern.
            Because we want to separate use of outgoing <em>Adapters</em> via a <em>secondary Port</em>, such as a <a href="http://martinfowler.com/eaaCatalog/repository.html"><em>Repository</em></a>
            in the DDD case, this can lead to a pattern for implementation of a Command:</p>
        <ol>
            <li>Begin Transaction</li>
            <li>Load from Repository</li>
            <li>Operate on Aggregate</li>
            <li>Flush to Repository</li>
            <li>Commit Transaction</li>
        </ol>
        <p>
            In the Repository pattern we may need to notify other Aggregates that can be eventually consistent of the change within the transaction ally consistent boundary. The pattern suggested there is a
            notification. Because the handling of that notification is in itself likely to be a transactional boundary for a different aggregate we can encapsulate this domain event with the Command design
            pattern as well, which gives rise to the following additional step to the sequence,outside the original transactional boundary:
        </p>
        <ul>
            <li>6. Invoke Command Encapsulating Notification</li>
        </ul>
        <p>This has obvious similarities to the <a href="http://en.wikipedia.org/wiki/Actor_model">actor model</a>, particularly if you use a Task Queue.</p>
        <p>The problems with the Command pattern are that the caller is coupled to a specific Command at the call site - which undermines the promise of being extensible through use of Commands.
            To change that Command, or call orthogonal services before calling the command requires us to amend the calling code, wherever the Command is used. To decouple a higher and lower layers
            we want to be able alter the implementation of the commands that we call on the lower layer without altering the calling layer.</p>
        <h2>Command Dispatcher</h2>
        <p>Brighter is a .NET implementation of the <strong>Command Dispatcher</strong> pattern.</p>
        <blockquote cite="http://hillside.net/plop/plop2001/accepted_submissions/PLoP2001/bdupireandebfernandez0/PLoP2001_bdupireandebfernandez0_1.pdf">
            This pattern increases the flexibility of applications by enabling their services to be changed, by adding, replacing or removing any command handlers
            at any point in time without having to modify, recompile or statically relink the application. By simulating the command-evaluation feature common in interpreted
            languages, this pattern supports the need for continual, incremental evolution of applications.
        </blockquote>
        <br/>
        <p>A <a href="http://en.wikipedia.org/wiki/Command_pattern"><strong>Command Dispatcher</strong></a> is often used with a <em>hierarchical architecture</em> to avoid
            the <a href="FatController.html">Fat Controller</a> problem and allow us to <a href="WhyCommandProcessor.html">decouple from the caller</a>. </p>
        <blockquote>An Action-Request object is an object that both encapsulates the identity of the action we want to fire and the parameters for this action, i.e. the extrinsic
            state of the action to undertake. In other words, an Action-Request object is a representation of the action to undertake, which is identified using a key,
            possibly a string such as 'set_depth'. An Action-Handler is the object that knows how to perform a particular action, and is passed the parameters at run-time. It is
            therefore a shared object that can be used in multiple contexts simultaneously. The Command-Dispatcher is the object that links the Action-Request to the appropriate
            Action Handler object. It has a dictionary that contains a reference to all the registered Action-Handlers. The Command-Dispatcher uses the Action-Request's key to find
            the right entry and dispatches the appropriate Action-Handler. The Action Handler can then perform the requested action.</blockquote>
        <br/>
        <p>We want to separate an Action-Request object that contains the identity of the action we want to perform, and the  parameter for that action from the Action-Handler
            which knows how to perform that action.</p>
        <p>A Command Dispatcher is an object that links the Action-Request with the appropriate Action-Handler.</p>
        <p>We may distinguish between a Command Action-Request that has one Action Handler and an Event Action-Request that has many</p>
        <p>The Command Dispatcher allows dynamic registration and removal of Command Handlers, it is an administrative entity that manages linking of commands to the appropriate command handlers.
        </p>
        <p>It relates to the Observer pattern in that hooks together publishers and subscribers.
        <p>Command Dispatcher registration requires a key – provided by the Command Dispatcher for the Commands it can service, using getKey(). [In practice we often use RTTI for this].
        </p>
        <p>The Command Handler is fired, when a command with the same name (key) is sent to the Command Dispatcher.
        </p>
        <p>The Command Dispatcher is a repository of key-value pairs (key., Command Handler) and when the Command Dispatcher is called it looks up the command’s key in the repository.
            If there is a match it calls the appropriate method(s) on the handler to process the Command.
        </p>
        <img src="images/CommandDispatcherClass.png" alt="Command Dispatcher Class Diagram">
        <p><strong>Invoker</strong> - has a lit of Commands that are to be executed</p>
        <p><strong>Command</strong> - represents the request to be processed, encapsulating the parameters to be passed to the command-handler to perform the request</p>
        <p><strong>Command Handler</strong> - specifies the interface that any command handler must implement</p>
        <p><strong>Concrete Command Handler</strong> – implements the request</p>
        <p><strong>Command Dispatcher</strong> – Allows dynamic registration of Command Handlers	 and looks up handlers for commands, by matching command and handler key.</p>
        <p><strong>Client</strong> – registers Commands with the Command Dispatcher.</p>
        <img src="images/Command%20Dispatcher.png" alt="Command Dispatcher sequence diagram">
        <br/>
        <p>A Command Dispatcher can also act as the <em>port</em> layer in a <a href="PortsAndAdapters.html"><em>Ports & Adapters</em></a>architecture.</p>
        <p>Finally, it's worth noting that Martin Fowler calls this component an<em>Event Processor</em> in his description of <a href="http://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a>
            and that this library facilitates the approach outlined there. It should be noted that the design of the Event Sourcing pattern outlined in the bliki,
            is somewhat different to the form outline by <a href="http://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf">Greg Young</a> which treats events as the storage mechanism
            and builds the current state from events. A discussion of the trade-offs it outside the scope of this documentation.</p>
         <h2>Command Processor</h2>
        <p>Brighter is a .NET implementation of the <a href="http://wiki.hsr.ch/APF/files/CommandProcessor.pdf"><strong>Command Processor</strong> pattern.</a></p>
        <blockquote cite="http://books.google.co.uk/books?id=0kUFZDuqvmEC&lpg=PA288&ots=MJzBAU9zGr&dq=posa%20command%20processor&pg=PA277#v=onepage&q&f=false">
            The Command Processor pattern separates the request for a service from its execution. A Command Processor component manages requests as separate objects,
            schedules their execution, and provides additional services such as the storing of request objects for later undo.
        </blockquote>
        <p>A Command Dispatcher and a Command Processor are similar in that both divorce the caller of a Command from invoker of that Command. However, the motivation is different.
           A Dispatcher seeks to decouple the caller from the invoker to allow us to easily extend the system without modification to the caller. Conversely the motivation behind a Command Processor
            is to allows us to implement orthogonal operations such as logging, or scheduling without forcing the sender or receiver to be aware of them. It does this by giving those responsibilities to
            the invoker.</p>
        <p>Of course as both patterns separate the invoker from sender and receiver, it is possible for us to combine them by having the Command Dispatcher's invoker support executing orthogonal concerns
        when it invokes the Command</p>
        <img src="images/CommandProcessorClass.png"/>
        <blockquote>The central command processor easily allows the addition of services related to command execution. An advanced command processor can log or store commands to a file for later
            examination or replay. A command processor can queue commands and schedule them at a later time. This is useful if commands should execute at a specified time, if they are handled according
            to priority, or if they will execute in a separate thread of control. An additional example is a single command processor shared by several concurrent applications that provides a
            transaction control mechanism with logging and rollback of commands.</blockquote>
        <br/>
        <p>A Command Processor enforces quality of service and maximizes throughput. A Command Processor forms a juncture at which concerns like: <a href="QualityOfServicePatterns.html">retry, timeout and
            circuit breaker</a> can be implemented for all commands</p>
        <img src="images/CommandProcessor.png" />
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>