<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
	<header>
        <h1>Paramore</h1>
		<p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="../index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="DistributedTaskQueueConfiguration.html">Next</a></p>
		<p><a href="ImplementingDistributedTaskQueue.html">Prev</a></p>
     </header>
    <section>
		<h1>Brighter</h1>
        <h2>Routing</h2>
		<h3>Publish-Subscribe</h3>
        <p>Brighter has a default Publish-Subscribe to messaging.</p>
        <p>A broker provides an intermediary between the producer of a message and a consumer. A consumer registers interest in
            messages that have a key or topic. A producer sends messages with a key or topic to a broker, and the broker
            sends a copy of that message to every subscribing consumer.
        </p>
        <p>In messaging we sometimes refer to the list of subscribers as a <a href="">Recipient List</a>, and because
            consumers can register their interest at runtime instead of build we sometimes calls this
            a <a href="">Dynamic Recipient List</a>.
        </p>
        <p>The publish subscribe model works particularly well with an <strong>Event-Driven Architecture</strong> (EDA).
            In an EDA one process, the publisher, raises an <strong>Event</strong> to indicate that something of interest
            happened within the process, such as an order being raised or a new customer being added, and subscribers who
            receive that message can act upon it. Processes can communicate back and forth with one process publishing an
            <strong>Event</strong> and another system reacting and publishing its <strong>Event</strong> message in turn.
            A <a href="">correlation id</a>, a unique identifier shared by the messages allows the original producer to
            correlate events raised by other producers to its message.
        </p>
        <p>The advantage of publish-subscribe is coupling. Because producers do not need to know about consumers and vice-versa
            then we can change the list of consumers without the producer needing to change, or change the producer
            without the consumer needing to know.
        </p>
        <h4>Routing Publish-Subscribe Messages</h4>
        <p>A producer routes messages to subscribers by setting a <strong>Topic</strong> on the <strong>MessageHeader</strong>.
            A <strong>Topic</strong> is just a string that you intend to use as a unique identifier for this message.
            A simple scheme can be the typename of the event for the Producer.
        </p>
        <p>When implementing an <strong>IAmAMessageMapper&lt;T&gt;</strong> you set the <strong>Topic</strong> in the
            <strong>MessageHeader</strong> when serializing your <strong>Command</strong> or <strong>Event</strong> to disk.
            In the following example we set the <strong>Topic</strong> to <em>Task.Completed</em>.
        </p>
<pre><code>
public class TaskCompletedEventMapper : IAmAMessageMapper&lt;TaskCompletedEvent&gt;
{
    public Message MapToMessage(TaskCompletedEvent request)
    {
        var header = new MessageHeader(messageId: request.Id, topic: "Task.Completed", messageType: MessageType.MT_EVENT);
        var body = new MessageBody(JsonConvert.SerializeObject(request));
        var message = new Message(header, body);
        return message;
    }
}
</code></pre>
        <p>On the consumer side we configure <strong>Perfomer</strong>s to subscribe to notifications from a Broker via
            a <strong>Channel</strong>. That <strong>Channel</strong> subscribes to the <strong>Topic</strong>. So in the
            above example to receive <strong>TaskCompletedEvent </strong> the <strong>Channel</strong> would need to subscribe
            to the <em>Task.Completed</em> <strong>Topic</strong>.
        </p>
        <p>We can configure consumers with code or configuration.</p>
        <p>Configuration is often used to allow us to make run-time changes to subscriber lists easily - by changing the
            configuration file and restarting the consumer. (Another alternative is to use the Control Bus to configure
            the consumer at run-time.
        </p>
        <p>To configure a consumer using a configuration file we use the service activator configuration section, which needs
            to be added to the <strong>&lt;configSections&gt;</strong> element of your configuration file.
        </p>
<pre><code>
&lt;section name="serviceActivatorConnections" type="paramore.brighter.serviceactivator.ServiceActivatorConfiguration.ServiceActivatorConfigurationSection, paramore.brighter.serviceactivator" allowLocation="true" allowDefinition="Everywhere" /&gt;
</code></pre>
        <p>To configure individual consumers we need to add elements to the <strong>&lt;serviceActivatorConnections&gt;</strong>
            element.
        </p>
<pre><code>
&lt;serviceActivatorConnections&gt;
    C&lt;connections&gt;
        &lt;add connectionName="paramore.example.greeting" channelName="greeting.command" routingKey="greeting.command" dataType="Greetings.Ports.Commands.GreetingCommand" timeOutInMilliseconds="200" /&gt;
    &lt;/connections&gt;
&lt;/serviceActivatorConnections&gt;
</code></pre>
        <p>The <strong>routingKey</strong> property of the connection must be the same key as used in the message mapper.
            This is passed to the broker to inform it that we want to subscribe to messages with that routing key on this channel.
        </p>
        <h3>Direct Messaging</h3>
        <p>In direct messaging a producer knows its consumer. A direct message can be fire and forget, which means it does
            not expect a reply, or request-reply which means that it does. In request-reply the receiver knows its sender
            as well.
        </p>
        <p>The reason you might choose direct messaging over publish-subscribe is consistency.
        </p>
        <p>When using publish-subscribe work queues we are eventually consistent - at some point in the future we will
            process the message, relying on 'at least once' delivery properties of the message queue. We don't know
            anything about 'when' that will happen. This means that two processes in our system may be inconsistent for
            a period of time - there is latency between them.
        </p>
        <p>Consider an application that needs to bill a customer's credit card.
        </p>
        <p>In an event driven approach, we could make the assumption that the transaction will succeed, raise a request to
            bill the customer and process the payment asynchronously. The producer of the billing request continues
            as though the transaction had succeeded. Eventually the customer is billed, and we are consistent. If we
            fail to bill the customer we have to take compensating action - raising a billing failed event, which may
            alert an operator and email the customer.
        </p>
        <p>Our reason for taking this approach may be that our payment provider is often slow to respond and we do not
            want to make the customer wait whilst we handle details of their payment. This may not simply be about
            responsiveness to the customer - it may be about scaling our system.
        </p>
        <p>In a direct messaging approach, we decide that as many payment transactions fail we do not want to process
            the order until the payment has been received. At the same time for throughput on our web server we want to
            work asynchronously and hand off the request to another process which calls the payment provider. Most likely
            we return a 202 Accepted from our HTTP API with a link to a resource to monitor for the results of the transaction.
            In our client we display a progress indicator until we have completed the transaction.
        </p>
        <p>In this case, our requirement is that we receive a response to our <strong>Command</strong> to bill.
        </p>
        <p>To route this kind of message the Producer needs to send a reply-address to the Consumer so that it can send
            a response back. In our case, that reply-address is a topic that the sender subscibes to in order to receive
            the response.
        </p>
        <p>Usually the Producer creates a topic for all of its replies, and matches request to response via a correlation id.
            This is simply a unique identifier that the Producer adds to the outgoing message.
        </p>
        <p>To help route direct messages we provide two classes, <strong>Request</strong> and <strong>Reply</strong> but the
            real work occurs within the message mapper itself.
        </p>
        <p>In the following code snippet we show both the Brighter library's <strong>ReplyAddress</strong> and
            <strong>Request</strong> as well a derived class <strong>HeartbeatRequest</strong> we use to
            represent a request for our service to respond with status information.
        </p>
        <p>Note also the correlation id that is added to the <strong>ReplyAddress</strong>.
        </p>
<pre><code>
public class ReplyAddress
{
    public ReplyAddress(string topic, Guid correlationId)
    {
        Topic = topic;
        CorrelationId = correlationId;
    }

    public string Topic { get; private set; }
    public Guid CorrelationId { get; private set; }
}

public class Request : Command
{
    public ReplyAddress ReplyAddress { get; private set; }

    public Request(ReplyAddress replyAddress)
    : base(Guid.NewGuid())
    {
        ReplyAddress = replyAddress;
    }
}

public class HeartbeatRequest : Request
{
    public HeartbeatRequest(ReplyAddress sendersAddress)
    : base(sendersAddress)
    {
    }
}
</code></pre>
      <p>When we convert this request into a <strong>Message</strong> via an <strong>IAmAMessageMapper</strong>
          we set the <strong>MessageHeader</strong> with the topic the Consumer should reply to. We also set the
          correlation id of the sender's message on the header.
      </p>
      <p>In the following code we also serialize the message back to a <strong>Command</strong> which is then routed by
         Brighter to a handler. When we serialize back to a <strong>Command</strong> we set the <strong>ReplyAddress</strong>
         with the Topic and Correlation Id.
      </p>
    <pre>
<code>
public class HeartbeatRequestCommandMessageMapper : IAmAMessageMapper&lt;HeartbeatRequest&gt;
{
    public Message MapToMessage(HeartbeatRequest request)
    {
        var header = new MessageHeader(
        messageId: request.Id,
        topic: &quot;Heartbeat&quot;,
        messageType: MessageType.MT_COMMAND,
        correlationId: request.ReplyAddress.CorrelationId,
        replyTo: request.ReplyAddress.Topic);

        var json = new JObject(new JProperty(&quot;Id&quot;, request.Id));
        var body = new MessageBody(json.ToString());
        var message = new Message(header, body);
        return message;
    }

    public HeartbeatRequest MapToRequest(Message message)
    {
        var replyAddress = new ReplyAddress(topic: message.Header.ReplyTo, correlationId: message.Header.CorrelationId);
        var request = new HeartbeatRequest(replyAddress);
        var messageBody = JObject.Parse(message.Body.Value);
        request.Id = Guid.Parse((string) messageBody[&quot;Id&quot;]);
        return request;
    }
}
</code>
</pre>
      <p>When we reply, we again use the message mapper to ensure that we route correctly.
      </p>
      <p> Our helper class this time is <strong>Reply</strong> which again encapsulates the reply-to address. We set this
          from the <strong>Command</strong> in our response. In this code our response to the <strong>HeartbeatRequest</strong>
          is to respond with a list of running consumers in the service.
      </p>
<pre><code>
public class Reply : Command
{
public ReplyAddress SendersAddress { get; private set; }

    public Reply(ReplyAddress sendersAddress)
    : base(Guid.NewGuid())
    {
        SendersAddress = sendersAddress;
    }
}

public class HeartbeatReply : Reply
{
    public HeartbeatReply(string hostName, ReplyAddress sendersAddress)
    :base(sendersAddress)
    {
        HostName = hostName;
        Consumers = new List&lt;RunningConsumer&gt;();
    }

    public string HostName { get; private set; }
    public IList&lt;RunningConsumer&gt; Consumers { get; private set; }
}

public class RunningConsumer
{
    public RunningConsumer(ConnectionName connectionName, ConsumerState state)
    {
        ConnectionName = connectionName;
        State = state;
    }

    public ConnectionName ConnectionName { get; private set; }
    public ConsumerState State { get; private set; }
}
</code></pre>
        <p>Again the key to responding is the <strong>IAmAMessageMapper</strong> implementation which uses the <strong>ReplyAddress</strong>
            to route the <strong>Message</strong> via its <strong>MessageHeader</strong> back to the caller.
        </p>
<pre><code>
class HeartbeatReplyCommandMessageMapper : IAmAMessageMapper&lt;HeartbeatReply&gt;
{
    public Message MapToMessage(HeartbeatReply request)
    {
        var header = new MessageHeader(
            messageId:request.Id,
            topic: request.SendersAddress.Topic,
            messageType: MessageType.MT_COMMAND,
            timeStamp: DateTime.UtcNow,
            correlationId: request.SendersAddress.CorrelationId
        );

        var json = new JObject(
            new JProperty(&quot;HostName&quot;, request.HostName),
            new JProperty(&quot;Consumers&quot;,
            new JArray(
                from c in request.Consumers
                select new JObject(
                    new JProperty(&quot;ConnectionName&quot;, c.ConnectionName.ToString()),
                    new JProperty(&quot;State&quot;, c.State)
                )
                )
            )
        );

        var body = new MessageBody(json.ToString());
        var message = new Message(header, body);
        return message;
    }

    public HeartbeatReply MapToRequest(Message message)
    {
        var messageBody = JObject.Parse(message.Body.Value);
        var hostName = (string) messageBody[&quot;HostName&quot;];
        var replyAddress = new ReplyAddress(message.Header.Topic, message.Header.CorrelationId);

        var reply = new HeartbeatReply(hostName, replyAddress);
        var consumers = (JArray) messageBody[&quot;Consumers&quot;];
        foreach (var consumer in consumers)
        {
            var connectionName = new ConnectionName((string)consumer[&quot;ConnectionName&quot;]);
            var state = (ConsumerState)Enum.Parse(typeof (ConsumerState), (string) consumer[&quot;State&quot;]);
            reply.Consumers.Add(new RunningConsumer(connectionName, state));
        }

        return reply;
    }
}
</code></pre>
        <h3>Summary</h3>
        <p>The key to understanding routing in Brighter <strong>IAmAMessageMapper</strong> implementation provides the point
            at which you control routing by setting the <strong>MessageHeader</strong>.
        </p>
  </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>