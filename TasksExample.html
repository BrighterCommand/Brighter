<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="PortsAndAdapters.html">Next</a></p>
        <p><a href="GreetingsExample.html">Prev</a></p>
    </header>
    <section>
        <h2>Tutorial</h2>
        <p>This tutorial takes you through buiding the TaskList project, which is ToDo MVC and Reminder Mail Service via a Task Queue. The application will manage a user's todo list, and sends notifications about imminent or overdue tasks.
            The walkthrough will build the examples available in the <a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples">Examples folder of Brighter available in the public repo</a> if you want to follow along there.</p>
        <p>Note that you will need to have <a href="https://www.rabbitmq.com/download.html">RabbitMQ</a> installed to step through this example as a tutorial.</p>

        <h3>Design Overview</h3>                
        <p>Tasks is intended to give a slightly fuller example of the use of Brighter to support a Web UI with supporting API and Application Service. Whilst we show snippets of code here, you will either want to clone Paramore from GitHub to follow along, or
            <a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples">browse the code</a> on the web.</p>
        <p>The separate components are:</p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples/TaskListUI" target="_blank">Tasklist UI</a>: An ASP.NET MVC UI SPA for the Tasklist API - least interesting from a Brighter perspective</li>
            <li><a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples/TaskList" target="_blank">Tasklist</a>: An HTTP API for tasks. Hosted in OpenRasta, uses <strong>Paramore.Brighter.CommandProcessor</strong></li>
            <li><a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples/TaskMailer" target="_blank">TaskMailer</a>: As service that notifies task owners of upcoming or overdue tasks, uses <strong>Paramore.Brighter.ServiceActivator</strong></li>
            <li><a href="https://github.com/iancooper/Paramore/tree/master/Brighter/Examples/Tasks" target="_blank">Tasks</a>: A core library that models Tasks used by both Tasklist and TaskMailer</li>
        </ul>
        <p>In a production SOA application we would consider all of these components to be part of the Tasks SOA and would be happy for these Autonomous Components within that  to
            share a model, as we are not crossing an SOA boundary. If we were to cross an SOA boundary we would not share the core library as we do here. </p>
        <p>
            Another way of stating this is these components are logically within a single bounded context, even though they are physically separate and we are using messaging to support Work Queues not integration SOA boundaries.
            We could use Brighter for SOA integration, but we would not share a model in that case, as a Service should share schema not type, and have explicit boundaries.</p>

        <h3>Prerequisites</h3>
        <p>We will assume you are familiar with:
        <ul>
            <li><a href="http://iancooper.github.io/Paramore/HelloWorldExample.html">Hello World</a> and <a href="http://iancooper.github.io/Paramore/GreetingsExample.html">Greetings</a> examples</li>
            <li>can add <a href="http://iancooper.github.io/Paramore/GreetingsExample.html">paramore.brighter.ServiceActivator</a> and <a href="http://iancooper.github.io/Paramore/HelloWorldExample.html">paramore.brighter.ComandProcessor</a> components</li>
            <li>can <a href="http://iancooper.github.io/Paramore/GreetingsExample.html">build/configure building paramore.brighter.CommandProcessor and Policies</a></li>
            <li>understand <a href="http://iancooper.github.io/Paramore/GreetingsExample.html">message Mappers</a></li>
            <li>and can configure <a href="https://github.com/grumpydev/TinyIoC">TinyIoc</a></li>
        </ul>
        
        <h2>Component Description</h2>
        <h3>Tasklist UI</h3>
        <p>A demo Web UI based upon todoMVC to offer a SPA-like representation of the TaskList API data</p>
        <p>Provides the following functionality:</p>
        <ul>
            <li>Get all Tasks</li>
            <li>Complete a Task</li>
            <li>Send Reminder for a Task</li>
        </ul>    
        <p>Hosted within iisExpress, uses MVC API to host SPA website written using jQuery, mustache and bootstrap</p>
        <h4>Where does Brighter fit in?</h4>
        <p>The UI acts as a dumb client to the Tasklist service. As such the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskListUI/app/app.js">app.js</a> file that contains the core logic issues GETs/POSTs that are processed by the TaskList API.</p>
        
        <h3>Tasklist (API)</h3>
        <p>Tasklist uses a Ports and Adapters architecture and the structure of the assembly surfaces that architectural style.</p>
        <p>Tasklist is responsible for providing API endpoints to support a UI implemented as a thin OpenRasta-API veneer to our Core Domain</p>
        <h4>TaskEndPointHandler</h4>
        <p>Responsible for REST operations on Task resources</p>
        <table>
            <thead>
                <h4>
                    <th>REST Operation</th>
                    <th>Port</th>
                    <th>Description</th>
                </h4>
            </thead>
            <tbody>
                <tr>
                    <td>GET /</td>
                    <td>ITaskListRetriever</td>
                    <td>Returns all tasks from the TaskList using a Port against our preferred Thin-Read model - a Retriever</td>
                </tr>
                <tr>
                    <td>GET /taskId</td>
                    <td>ITaskRetriever</td>
                    <td>Returns a specified task from the TaskList using a Port against our preferred Thin-Read model - a Retriever</td>
                </tr>
                <tr>
                    <td>POST {TaskModel}</td>
                    <td>AddTaskCommandHandler</td>
                    <td>Adds a new task specified by the TaskModel a Port against our preferred Domain-Write model - a <strong>IHandleRequests&lt;TRequest&gt;</strong></td>
                </tr>
                <tr>
                    <td>DELETE /taskId</td>
                    <td>CompleteTaskCommandHandler</td>
                    <td>Completes a given task specified by the taskId with a Port against our preferred Domain-Write model - a <strong>IHandleRequests&lt;TRequest&gt;</strong></p>. A command is therefore dispatched to the CommandProcessor</td>
                </tr>
            </tbody>
        </table>
        <h4>TaskReminderEndpointHandler</h4>
        <p>Responsible for REST operations on Task Reminder resources. Implemented as a shallow Adaptor to transformm POSTed arguments into Commands that will be handled by a Port</p>
        <p>It should be noted the Handler contains no Port for handling the command. This will be processed by the separate TaskMailer Service.</p>
        <table>
            <thead>
                <h5>
                    <th>REST Operation</th>
                    <th>Mapper/Port</th>
                    <th>Description</th>
                </h5>
            </thead>
            <tbody>
                <tr>
                    <td>POST {TaskReminderModel}</td>
                    <td>n/a</td>
                    <td>Receives the arguments via HTTP and posts a TaskReminderCommand</td>
                </tr>
            </tbody>
        </table>
        <h4>Where does Brighter fit in?</h4>
<p>Once <a href="http://openrasta.org/">OpenRasta</a> unpacks the Request (in <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Handlers/TaskEndPointHandler.cs">TaskEndPointHandler</a> and <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Handlers/TaskReminderEndpointHandler.cs">TaskReminderEndpointHandler</a>) the relevant Port is invoked.</p>
<p>On the Read-side this is a View Model retriever, and in TaskList this derives from <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Ports/ViewModelRetrievers/SimpleDataRetriever.cs">SimpleDataRetriever</a>.</p>
<p>The Write-side will invoke a Handler in Tasklist that maps to IHandle&lt;TaskReminderCommand&gt; or IHandle&lt;TaskReminderCommand&gt;. These handlers can be found in Tasks <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/Tasks/Ports/MailTaskReminderHandler.cs">MailTaskReminderHandler</a> and <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/Tasks/Ports/Handlers/AddTaskCommandHandler.cs">AddTaskCommandHandler</a>.</p>

        <h3>TaskMailer</h3>
        <p>A separate service responsible for sending emails using Azure SendGrid</p>
        <table>
            <thead>
                <h4>
                    <th>REST Operation</th>
                    <th>Port</th>
                    <th>Description</th>
                </h4>
            </thead>
            <tbody>
                <tr>
                    <td>POST {TaskReminderModel}</td>
                    <td>TaskReminderCommandMessageMapper</td>
                    <td>API to receive the POST to send a Reminder. The TaskReminderCommand is then mapped through TaskReminderCommandMessageMapper to demonstrate Message Transformation </td>
                </tr>
                <tr>
                    <td></td>
                    <td>MailTaskReminderHander</td>
                    <td>Processes transformed message and initiates Mail Sending using the MailGateway.</td>
                </tr>
            </tbody>
        </table>
        <h4>Where does Brighter fit in?</h4>
        <p>A standalone service that implements Brighter's Service Activator. This allows <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskMailer/Adapters/ServiceHost/TaskMailerService.cs">mapping of closures to commands (via IoC), specifying Policy and building Dispatcher and CommandProcessor</a>.</p>
<p>The TaskMailService class achieves all of this in &lt; 100 lines, thanks to <a href="https://www.nuget.org/packages/paramore.brighter.serviceactivator/">Paramore.Brighter.ServiceActivator</a></p>

        <h3>Tasks</h3>
        <p>Tasks is the Core Domain model using a <strong><a href="PortsAndAdapters.html">Ports and Adapters architecture</a></strong> and the structure of the assembly surfaces that architectural style.</p>
        <p>The <strong>Ports</strong> folder contains a folder for our <strong>Handlers</strong>, which implement <strong>IHandleRequests&lt;TRequest&gt;</strong>. These form the ports into our application. </p>    
        <h4>Where does Brighter fit in?</h4>
        <p>This is a library component of TaskList containing core domain. As such Commands are here (and referenced by consumers/producers internal to the SOA boundary). Core Ports are also held here along with Adaptors.</p>
        <p>As such <strong>Paramore.Brighter.ComamndProcessor</strong> is referenced to allow coding Write-side ports, and to adapt any incoming Commands/Events.</p>

        <h2>Walkthrough - Get Tasks</h2>
        <h3>UI</h3>
        <p>The UI loads jquery and fires a js request to the hosted API (at <code>localhost:49743</code>). Almost all code is in a singular js file... a snippet shows the expected jQuery code:
            <pre><code>var taskVm = function () {
    var baseUri = 'http://localhost:49743/tasks';
    var getTasksInternal = function(getCallback) {
        $.ajax({
            url: baseUri,
            dataType: 'json',
            type: 'GET',
            success: function(data) { getCallback(data); }
        });
    };
    ...
    }
    return {
        getTasks: getTasksInternal,
        ...
    };
}();
</code></pre>
    </p>
        <h3>TaskList API</h3>
        <p>Once received, an OpenRasta translates the GET and invokes the configured handler, <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Handlers/TaskEndPointHandler.cs">TaskEndPointHandler</a>.</p>
        <pre><code>[HttpOperation(HttpMethod.GET)]
public OperationResult Get()
{
    TaskListModel responseResource = _taskListRetriever.RetrieveTasks();
    return new OperationResult.OK { ResponseResource = responseResource };
}
</code></pre>

        <p>Our read-side is simple, with no adaptor needed (as no input is passed over HTTP). Therefore we can simply invoke the read-side Port, the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Ports/ViewModelRetrievers/TaskListRetriever.cs">TaskList View Model Retriever</a>:</p>

        <h4>TaskList View Model Retriever</h4>
        <pre><code>public dynamic RetrieveTasks()
{
    var db = Database.Opener.OpenFile(DatabasePath);
    var tasks = db.Tasks.All().ToList<Task>();
    var taskList = new TaskListModel(tasks, _hostName);
    return taskList;
}
</code></pre>
            
        <h2>Walkthrough - Add a Task</h2>
        <h3>UI</h3>
        <p>The javascript ViewModel sends a js request to the hosted API (at <code>localhost:49743</code>):
            <pre><code>var taskVm = function () {
    ...
    var addTaskInternal = function(taskText, addCallback) {
        $.ajax({
            url: baseUri,
            dataType: 'text', //to process location, not json
            type: 'POST',
            success: function(data) { addCallback(data); },
            contentType: "application/json",
            data: '{"dueDate": "' + dueDateFixed + '", "taskDescription": "' + taskText + '", "taskName": "' + taskText + '"}'
        });
    };
    ...
    }
    return {
        addTask: addTaskInternal,
        ...
    };
}();
</code></pre>
</p>
        <h3>TaskList API</h3>
        <p>Again OpenRasta translates the POST and invokes the configured handler, <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Handlers/TaskEndPointHandler.cs">TaskEndPointHandler</a>.</p>
        <p>Our write-side is more involved. The received data is transformed into a Command that can be understood by the core domain (AddTaskCommand. The command is then posted to the CommandProcessor to locate the approptiate handler:</p>
            <pre><code>[HttpOperation(HttpMethod.POST)]
public OperationResult Post(TaskModel newTask)
{
    var addTaskCommand = new AddTaskCommand(
        taskName: newTask.TaskName,
        taskDescription: newTask.TaskDescription,
        dueDate: DateTime.Parse(newTask.DueDate)
        );

    _commandProcessor.Send(addTaskCommand);

    return new OperationResult.Created
    {
        RedirectLocation = new Uri(string.Format("{0}/tasks/{1}", _communicationContext.ApplicationBaseUri, addTaskCommand.TaskId))
    };
}
</code></pre>
        <p>The relevant handler (<a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/Tasks/Ports/Handlers/AddTaskCommandHandler.cs">AddTaskCommandHandler</a>) will handle the command (as it was configured to handle AddTaskCommand in the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Configuration/DependencyRegistrar.cs">TaskList dependency registrar</a>.</p>
        <p>The handler is very simple - simpyl adding the given state using the TasksDao:</p>
        <pre><code>[RequestLogging(step: 1, timing: HandlerTiming.Before)]
[Validation(step: 2, timing: HandlerTiming.Before)]
[UsePolicy(CommandProcessor.RETRYPOLICY, step: 3)]
public override AddTaskCommand Handle(AddTaskCommand addTaskCommand)
{
    using (var scope = _tasksDAO.BeginTransaction())
    {
        var inserted = _tasksDAO.Add(
            new Task(
                taskName: addTaskCommand.TaskName,
                taskDecription: addTaskCommand.TaskDescription,
                dueDate: addTaskCommand.TaskDueDate
                )
            );

        scope.Commit();

        addTaskCommand.TaskId = inserted.Id;
    }

    return addTaskCommand;
}
</code></pre>
        <p>The TasksDAO is an abstraction over the sqlce datastore for Tasks and uses <a href="https://github.com/markrendle/Simple.Data">simple.data</a> to access the database.</p>

        <h2>Walkthrough - Mail a reminder</h2>
        <h3>UI</h3>
        <p>From the UI 'completing' a task is modelled as a DELETE being issued to the relevant tasks endpoint:</p>
            <pre><code>var taskVm = function () {
    ...
    var completeTaskInternal = function(taskId, completeCb) {
        $.ajax({
            url: baseUri + '/' + taskId,
            dataType: 'text',
            type: 'DELETE',
            success: function(data) { completeCb(data); }
        });
    };
    ...
    }
    return {
        completeTask: completeTaskInternal,
        ...
    };
}();
</code></pre>

        <h3>TaskList API</h3>
        <p>OpenRasta translates the DELETE and invokes the configured handler, <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskList/Adapters/API/Handlers/TaskReminderEndPointHandler.cs">TaskReminderEndPointHandler</a>.</p>
        <p>The received data is transformed into a Command that can be understood by the core domain (TaskReminderCommand). The command is then posted tp the CommandProcessor to locate the approptiate handler.</p>
            <pre><code>[HttpOperation(HttpMethod.POST)]
public OperationResult Post(TaskReminderModel reminder)
{
    var reminderCommand = new TaskReminderCommand(
        taskName: reminder.TaskName,
        dueDate: DateTime.Parse(reminder.DueDate),
        recipient: reminder.Recipient,
        copyTo: reminder.CopyTo
        );
    _commandProcessor.Post(reminderCommand);

    return new OperationResult.OK(){StatusCode = (int)HttpStatusCode.Accepted};
}
</code></pre>
        <p>The relevant handler (<a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/Tasks/Ports/MailTaskReminderHandler.cs">MailTaskReminderHandler</a>) will pick up the command (as it was configured to handle TaskReminderCommand in the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/Examples/TaskMailer/Adapters/ServiceHost/TaskMailerService.cs">TaskMailerService (that handles it's own dependency registration)</a>.</p>
        <p>The handler is very simple - it invokes the MailGateway to send the email:</p>
        <pre><code>
[RequestLogging(step: 1, timing: HandlerTiming.Before)]
[UsePolicy(CommandProcessor.CIRCUITBREAKER, step: 2)]
[UsePolicy(CommandProcessor.RETRYPOLICY, step: 3)]
public override TaskReminderCommand Handle(TaskReminderCommand command)
{
    _mailGateway.Send(new TaskReminder(
        taskName: new TaskName(command.TaskName),
        dueDate: command.DueDate,
        reminderTo: new EmailAddress(command.Recipient),
        copyReminderTo: new EmailAddress(command.CopyTo)
        ));

    return base.Handle(command);
}
</code></pre>

    The resulting functionality is exposed as a 'ToDo MVC' clone. The real value is understanding the Paramore concepts at play.
    <img src="images/todo.png" />
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>