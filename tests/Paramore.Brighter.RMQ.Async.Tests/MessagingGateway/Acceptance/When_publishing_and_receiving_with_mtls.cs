using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Paramore.Brighter.MessagingGateway.RMQ.Async;
using Xunit;

namespace Paramore.Brighter.RMQ.Async.Tests.MessagingGateway.Acceptance;

// Acceptance tests verify actual mTLS connections to Docker RabbitMQ
// These tests run against the actual transport configured in Docker (per ADR #3946)
[Trait("Category", "RabbitMQ")]
[Trait("Category", "MutualTLS")]
[Trait("Requires", "Docker-mTLS")]
public class RmqMutualTlsAcceptanceTests : IDisposable
{
    private readonly string _clientCertPath;
    private const string CertPassword = "test-password";

    public RmqMutualTlsAcceptanceTests()
    {
        // Path to client certificate generated by generate-test-certs.sh
        _clientCertPath = Path.Combine(
            AppDomain.CurrentDomain.BaseDirectory,
            "..",
            "..",
            "..",
            "..",
            "certs",
            "client-cert.pfx");
    }

    public void Dispose()
    {
        // Cleanup if needed
    }

    [Fact]
    public async Task When_connecting_with_client_certificate_can_publish_message_async()
    {
        // Verify certificate exists
        if (!File.Exists(_clientCertPath))
        {
            throw new FileNotFoundException(
                $"Client certificate not found at {_clientCertPath}. " +
                "Run ./tests/generate-test-certs.sh to generate certificates.");
        }

        // Arrange
        var connection = new RmqMessagingGatewayConnection
        {
            AmpqUri = new AmqpUriSpecification(new Uri("amqps://localhost:5671")),
            Exchange = new Exchange("test.mtls.exchange.async"),
            ClientCertificatePath = _clientCertPath,
            ClientCertificatePassword = CertPassword,
            TrustServerSelfSignedCertificate = true  // Trust self-signed certificates in test environment
        };

        // Act
        var producer = new RmqMessageProducer(connection);
        var message = new Message(
            new MessageHeader(Id.Random(), "test.mtls.topic.async", MessageType.MT_EVENT),
            new MessageBody("Test message over mTLS (async)")
        );

        // Assert - Should NOT throw TLS handshake exception
        // Actual TLS handshake occurs when SendAsync() is called
        await producer.SendAsync(message);

        // If we reach here, TLS handshake succeeded
        Assert.True(true);

        // Cleanup
        await producer.DisposeAsync();
    }

    [Fact]
    public async Task When_connecting_with_mtls_can_publish_and_receive_message_async()
    {
        // Verify certificate exists
        if (!File.Exists(_clientCertPath))
        {
            throw new FileNotFoundException(
                $"Client certificate not found at {_clientCertPath}. " +
                "Run ./tests/generate-test-certs.sh to generate certificates.");
        }

        // Arrange
        var queueName = $"test.mtls.queue.async.{Id.Random()}";
        var routingKey = "test.mtls.roundtrip.async";

        var connection = new RmqMessagingGatewayConnection
        {
            AmpqUri = new AmqpUriSpecification(new Uri("amqps://localhost:5671")),
            Exchange = new Exchange("test.mtls.exchange.async"),
            ClientCertificatePath = _clientCertPath,
            ClientCertificatePassword = CertPassword,
            TrustServerSelfSignedCertificate = true  // Trust self-signed certificates in test environment
        };

        // Act - Create consumer first to ensure queue exists and is bound
        var consumer = new RmqMessageConsumer(connection, queueName, routingKey, false);
        consumer.Purge(); // Ensure queue is created and bound before publishing

        // Act - Publish
        var producer = new RmqMessageProducer(connection);
        var sentMessage = new Message(
            new MessageHeader(Id.Random(), routingKey, MessageType.MT_EVENT),
            new MessageBody("Round-trip test over mTLS (async)")
        );
        await producer.SendAsync(sentMessage);

        // Act - Consume
        var receivedMessages = await consumer.ReceiveAsync(TimeSpan.FromSeconds(5));

        // Assert
        Assert.NotEmpty(receivedMessages);
        var receivedMessage = receivedMessages.First();
        Assert.Equal(sentMessage.Id, receivedMessage.Id);
        Assert.Equal(sentMessage.Body.Value, receivedMessage.Body.Value);

        // Cleanup
        await producer.DisposeAsync();
        await consumer.DisposeAsync();
    }
}
