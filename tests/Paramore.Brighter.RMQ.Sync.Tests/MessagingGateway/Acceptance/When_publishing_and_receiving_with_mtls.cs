using System;
using System.IO;
using Paramore.Brighter.MessagingGateway.RMQ.Sync;
using Xunit;

namespace Paramore.Brighter.RMQ.Sync.Tests.MessagingGateway.Acceptance;

// Acceptance tests verify actual mTLS connections to Docker RabbitMQ
// These tests run against the actual transport configured in Docker (per ADR #3946)
[Trait("Category", "RabbitMQ")]
[Trait("Category", "MutualTLS")]
[Trait("Requires", "Docker-mTLS")]
[Collection("RabbitMQ mTLS")]
public class RmqMutualTlsAcceptanceTests : IDisposable
{
    private readonly string _clientCertPath;
    private const string CertPassword = "test-password";

    public RmqMutualTlsAcceptanceTests()
    {
        // Path to client certificate generated by generate-test-certs.sh
        _clientCertPath = Path.Combine(
            AppDomain.CurrentDomain.BaseDirectory,
            "..",
            "..",
            "..",
            "..",
            "certs",
            "client-cert.pfx");
    }

    public void Dispose()
    {
        // Cleanup if needed
    }

    [Fact]
    public void When_connecting_with_client_certificate_can_publish_message_sync()
    {
        // Verify certificate exists
        if (!File.Exists(_clientCertPath))
        {
            throw new FileNotFoundException(
                $"Client certificate not found at {_clientCertPath}. " +
                "Run ./tests/generate-test-certs.sh to generate certificates.");
        }

        // Arrange
        var connection = new RmqMessagingGatewayConnection
        {
            AmpqUri = new AmqpUriSpecification(new Uri("amqps://localhost:5671")),
            Exchange = new Exchange("test.mtls.exchange.sync"),
            ClientCertificatePath = _clientCertPath,
            ClientCertificatePassword = CertPassword,
            TrustServerSelfSignedCertificate = true  // Trust self-signed certificates in test environment
        };

        // Act
        using var producer = new RmqMessageProducer(connection);
        var message = new Message(
            new MessageHeader(Id.Random(), "test.mtls.topic", MessageType.MT_EVENT),
            new MessageBody("Test message over mTLS (sync)")
        );

        // Assert - Should NOT throw TLS handshake exception
        // Actual TLS handshake occurs when Send() is called
        producer.Send(message);

        // If we reach here, TLS handshake succeeded
        Assert.True(true);
    }

    [Fact]
    public void When_connecting_with_mtls_can_publish_and_receive_message_sync()
    {
        // Verify certificate exists
        if (!File.Exists(_clientCertPath))
        {
            throw new FileNotFoundException(
                $"Client certificate not found at {_clientCertPath}. " +
                "Run ./tests/generate-test-certs.sh to generate certificates.");
        }

        // Arrange
        var queueName = $"test.mtls.queue.{Id.Random()}";
        var routingKey = "test.mtls.roundtrip";

        var connection = new RmqMessagingGatewayConnection
        {
            AmpqUri = new AmqpUriSpecification(new Uri("amqps://localhost:5671")),
            Exchange = new Exchange("test.mtls.exchange.sync"),
            ClientCertificatePath = _clientCertPath,
            ClientCertificatePassword = CertPassword,
            TrustServerSelfSignedCertificate = true  // Trust self-signed certificates in test environment
        };

        // Act - Create consumer first to ensure queue exists and is bound
        using var consumer = new RmqMessageConsumer(connection, queueName, routingKey, false);
        consumer.Purge(); // Ensure queue is created and bound before publishing

        // Act - Publish
        using var producer = new RmqMessageProducer(connection);
        var sentMessage = new Message(
            new MessageHeader(Id.Random(), routingKey, MessageType.MT_EVENT),
            new MessageBody("Round-trip test over mTLS (sync)")
        );
        producer.Send(sentMessage);

        // Act - Consume
        var receivedMessages = consumer.Receive(TimeSpan.FromSeconds(5));

        // Assert
        Assert.NotNull(receivedMessages);
        Assert.NotEmpty(receivedMessages);
        var receivedMessage = receivedMessages[0];
        Assert.Equal(sentMessage.Id, receivedMessage.Id);
        Assert.Equal(sentMessage.Body.Value, receivedMessage.Body.Value);
    }
}
