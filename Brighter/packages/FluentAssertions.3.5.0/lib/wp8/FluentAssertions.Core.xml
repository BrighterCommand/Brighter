<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentAssertions.Core</name>
    </assembly>
    <members>
        <member name="M:FluentAssertions.AndConstraint`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:FluentAssertions.AndWhichConstraint`2">
            <summary>
            Constraint which can be returned from an assertion which matches a condition and which will allow
            further matches to be performed on the matched condition as well as the parent constraint.
            </summary>
            <typeparam name="TParentConstraint">The type of the original constraint that was matched</typeparam>
            <typeparam name="TMatchedElement">The type of the matched object which the parent constraint matched</typeparam>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Which">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Subject">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
            <remarks>
            Just a convenience property that returns the same value as <see cref="P:FluentAssertions.AndWhichConstraint`2.Which"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.AssertionOptions">
            <summary>
            Holds any global options that control the behavior of FluentAssertions.
            </summary>
        </member>
        <member name="F:FluentAssertions.AssertionOptions.IsValueType">
            <summary>
            Defines a predicate with which the <see cref="T:FluentAssertions.Equivalency.EquivalencyValidator"/> determines if it should process 
            an object's properties or not. 
            </summary>
            <returns>
            Returns <c>true</c> if the object should be treated as a value type and its <see cref="M:System.Object.Equals(System.Object)"/>
            must be used during a structural equivalency check.
            </returns>
        </member>
        <member name="M:FluentAssertions.AssertionOptions.AssertEquivalencyUsing(System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions,FluentAssertions.Equivalency.EquivalencyAssertionOptions})">
            <summary>
            Allows configuring the defaults used during a structural equivalency assertion.
            </summary>
            <param name="defaultsConfigurer">
            An action that is used to configure the defaults.
            </param>
        </member>
        <member name="P:FluentAssertions.AssertionOptions.EquivalencySteps">
            <summary>
            Represents a mutable collection of steps that are executed while asserting a (collection of) object(s) 
            is structurally equivalent to another (collection of) object(s).
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.Generic.IEnumerable`1"/> is in the expectation state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.CollectionAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.IEnumerable"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.ReferenceTypeAssertions`2">
            <summary>
            Contains a number of methods to assert that a reference type object is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has not been initialized yet.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has been initialized.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to the exact same object as another object reference.
            </summary>
            <param name="expected">The expected object</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to a different object than another object reference refers to.
            </summary>
            <param name="unexpected">The unexpected object</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The expected type of the object.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is assignable to a variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which the object should be assignable.</typeparam>
            <param name="because">The reason why the object should be assignable to the type.</param>
            <param name="reasonArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndWhichConstraint`2"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate"/> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject"/>.</param>
            <param name="because">The reason why the predicate should be satisfied.</param>
            <param name="reasonArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate"/> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject"/>.</param>
            <param name="because">The reason why the predicate should be satisfied.</param>
            <param name="reasonArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is null or does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is not null and contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.OnlyHaveUniqueItems(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any duplicate items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotContainNulls(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any <c>null</c> items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Equal(System.Object[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by 
            <paramref name="elements"/>. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Equal(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by 
            <paramref name="expected"/>. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotEqual(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all the same elements in the same order as the collection identified by 
            <paramref name="unexpected"/>. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.IEnumerable"/> with the elements that are not expected.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEquivalentTo(System.Object[])">
            <summary>
            Expects the current collection to contain all elements of the collection identified by <paramref name="elements"/>,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEquivalentTo(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain all elements of the collection identified by <paramref name="expected"/>,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeEquivalentTo(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all elements of the collection identified by <paramref name="unexpected"/>,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.IEnumerable"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainItemsAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the current collection only contains items that are assignable to the type <typeparamref name="T"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Contain(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainInOrder(System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainInOrder(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            </summary>
            <remarks>
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation. 
            </remarks>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInAscendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInDescendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInOrder(FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in the specified <paramref name="expectedOrder"/>.
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeAscendingInOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeDescendingInOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)"/> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeInOrder(FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeSubsetOf(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection is a subset of the <paramref name="expectedSuperset"/>.
            </summary>
            <param name="expectedSuperset">An <see cref="T:System.Collections.IEnumerable"/> with the expected superset.</param>
            <param name="because">        
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeSubsetOf(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection is not a subset of the <paramref name="unexpectedSuperset"/>.
            </summary>
            <param name="unexpectedSuperset">An <see cref="T:System.Collections.IEnumerable"/> with the unexpected superset.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveSameCount(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Assert that the current collection has the same number of elements as <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The other collection with the same expected number of elements</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementAt(System.Int32,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection has the supplied <paramref name="element"/> at the 
            supplied <paramref name="index"/>.
            </summary>
            <param name="index">The index where the element is expected</param>
            <param name="element">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotContain(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied <paramref name="unexpected"/> item.
            </summary>
            <param name="unexpected">The element that is not expected to be in the collection</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.IntersectWith(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection shares one or more items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.IEnumerable"/> with the expected shared items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotIntersectWith(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection does not share any items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.IEnumerable"/> to compare to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.StartWith(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the collection starts with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the start of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.EndWith(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the collection ends with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the end of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementPreceding(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly precedes the <paramref name="successor"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementSucceeding(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly succeeds the <paramref name="predecessor"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.CollectionAssertions`2.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches the supplied <paramref name="expected"/> amount.
            </summary>
            <param name="expected">The expected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches a condition stated by the <paramref name="countPredicate"/>.
            </summary>
            <param name="countPredicate">A predicate that yields the number of items that is expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Equal(`0[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by 
            <paramref name="elements"/>. Elements are compared using their <see cref="!:T.Equals(T)"/> method.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Equal(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that two collections contain the same items in the same order, where equality is determined using a 
            predicate.
            </summary>
            <param name="expectation">
            The collection to compare the subject with.
            </param>
            <param name="predicate">
            A predicate the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(`0,System.String,System.Object[])">
            <summary>
            Asserts that the collection contains the specified item.
            </summary>
            <param name="expected">The expectation item.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Asserts that the collection contains some extra items in addition to the original items.
            </summary>
            <param name="expectedItemsList">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of expectation items.</param>
            <param name="additionalExpectedItems">Additional items that are expectation to be contained by the collection.</param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least one item that matches the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.OnlyContain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection only contains items that match a predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.NotContain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items that match the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.ContainSingle(System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.ContainSingle(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item matching the specified <paramref name="predicate"/>.
            </summary>
            <param name="predicate">The predicate that will be used to find the matching items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.WhichValueConstraint`2.WhichValue">
            <summary>
            Gets the value of the object referred to by the key.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.DateTimeExtensions.ToDateTimeOffset(System.DateTime)">
            <summary>
            Converts an existing <see cref="T:System.DateTime"/> to a <see cref="T:System.DateTimeOffset"/> but normalizes the <see cref="T:System.DateTimeKind"/> 
            so that comparisons of converted <see cref="T:System.DateTime"/> instances retain the UTC/local agnostic behavior.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.IProvidePlatformServices">
            <summary>
            Defines the contract the platform-specific assembly must implement to be able to get a chance to initialize itself.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.PlatformAdapter">
            <summary>
            Facade to resolve an implementation of a particular interface using a platform-specific assembly.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.ProbingAdapterResolver">
            <summary>
            An implementation of <see cref="T:FluentAssertions.Common.IAdapterResolver"/> that probes for platforms-specific adapters by dynamically
            looking for concrete types in platform-specific assemblies.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.MultiDimensionalArrayEquivalencyStep">
            <summary>
            Supports recursively comparing two multi-dimensional arrays for equivalency using strict order for the array items 
            themselves.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyStep">
            <summary>
            Defines a step in the process of comparing two object graphs for structural equivalency.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllPublicFieldsSelectionRule">
            <summary>
            Selection rule that adds all public fields of the subject. 
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberSelectionRule">
            <summary>
            Represents a rule that defines which members of the subject-under-test to include while comparing
            two objects for structural equality.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberSelectionRule.SelectMembers(System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.SelectedMemberInfo},FluentAssertions.Equivalency.ISubjectInfo,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Adds or removes properties to/from the collection of subject members that must be included while
            comparing two objects for structural equality.
            </summary>
            <param name="selectedMembers">
                A collection of members that was prepopulated by other selection rules. Can be empty.</param>
            <param name="context"></param>
            <param name="config"></param>
            <param name="info">
            Type info about the subject.
            </param>
            <returns>
            The collection of members after applying this rule. Can contain less or more than was passed in.
            </returns>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberSelectionRule.IncludesMembers">
            <summary>
            Gets a value indicating whether this rule should override the default selection rules that include all members. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllPublicFieldsSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.EquivalencyStepCollection">
            <summary>
            Represents a mutable collection of equivalency steps that can be reordered and/or amended with additional
            custom equivalency steps. 
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Add``1">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> after any of the built-in steps, with the exception of the final 
            <see cref="T:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.AddAfter``2">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> right after the specified <typeparamref name="TPredecessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Insert``1">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> before any of the built-in steps. 
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.InsertBefore``2">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> just before the <typeparamref name="TSuccessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Remove``1">
            <summary>
            Removes all instances of the specified <typeparamref name="TStep"/> from the current step.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Clear">
            <summary>
            Removes each and every built-in <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IAssertionContext`1">
            <summary>
            Provides the required information for executing an equality assertion between a subject and an expectation.
            </summary>
            <typeparam name="TSubject">The type of the subject.</typeparam>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.SubjectProperty">
            <summary>
            Gets the <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Subject">
            <summary>
            Gets the value of the <see cref="P:FluentAssertions.Equivalency.IAssertionContext`1.SubjectProperty"/>
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Expectation">
            <summary>
            Gets the value of the expectation object that was matched with the subject using a <see cref="T:FluentAssertions.Equivalency.IMemberMatchingRule"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Reason">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.ReasonArgs">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRuleEquivalencyStep`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionRuleEquivalencyStepAdapter">
            <summary>
            Adaptor allowing an IAssertionRule to be used where a IEquivalencyStep is required.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberMatchingRule">
            <summary>
            Represents a rule that defines how to map the members from the subject-under-test with the members 
            on the expectation object. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberMatchingRule.Match(FluentAssertions.Equivalency.SelectedMemberInfo,System.Object,System.String,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Attempts to find a member on the expectation that should be compared with the 
            <paramref name="subjectMember"/> during a structural equality.
            </summary>
            <remarks>
            Whether or not a match is required or optional is up to the specific rule. If no match is found and this is not an issue,
            simply return <c>null</c>.
            </remarks>
            <param name="subjectMember">
            The <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the subject's member for which a match must be found. Can never
            be <c>null</c>.
            </param>
            <param name="expectation">
            The expectation object for which a matching member must be returned. Can never be <c>null</c>.
            </param>
            <param name="memberPath">
            The dotted path from the root object to the current member. Will never  be <c>null</c>.
            </param>
            <param name="config"></param>
            <returns>
            Returns the <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the property with which to compare the subject with, or <c>null</c>
            if no match was found.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.IOrderingRule">
            <summary>
            Defines a rule that is used to determine whether the order of items in collections is relevant or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IOrderingRule.AppliesTo(FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="subjectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.ISubjectInfo">
            <summary>
            Provides details about the subject's root or nested member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberInfo">
            <summary>
            Gets the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberInfo"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberPath">
            <summary>
            Gets the full path from the root object until the current object separated by dots.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberDescription">
            <summary>
            Gets a display-friendly representation of the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberPath"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.PropertyInfo">
            <summary>
            Gets the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.PropertyInfo"/> of the property that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.PropertyPath">
            <summary>
            Gets the full path from the root object until the current object separated by dots.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.PropertyDescription">
            <summary>
            Gets a display-friendly representation of the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.PropertyPath"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object and the type is not <see cref="T:System.Object"/>, 
            then it returns the same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.ISubjectInfo.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumEqualityStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumEqualityStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumerableEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the verificationScope subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumerableEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1">
            <summary>
            Represents the run-time behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyAssertionOptions">
            <summary>
            Provides the run-time details of the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsValueType(System.Type)">
            <summary>
            Gets a value indicating whether the <paramref name="type"/> should be treated as having value semantics.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.SelectionRules">
            <summary>
            Gets an ordered collection of selection rules that define what properties are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.MatchingRules">
            <summary>
            Gets an ordered collection of matching rules that determine which subject properties are matched with which
            expectation properties.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsRecursive">
            <summary>
            Gets a value indicating whether or not the assertion must perform a deep comparison.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.AllowInfiniteRecursion">
            <summary>
            Gets a value indicating whether recursion is allowed to continue indefinitely.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CyclicReferenceHandling">
            <summary>
            Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.OrderingRules">
            <summary>
            Gets an ordered collection of rules that determine whether or not the order of collections is important. By default,
            ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.EnumEquivalencyHandling">
            <summary>
            Gets value indicating how the enums should be compared.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UserEquivalencySteps">
            <summary>
            Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UseRuntimeTyping">
            <summary>
            Gets a value indicating whether the runtime type should be used rather than the declared type.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeProperties">
            <summary>
            Gets a value indicating whether properties should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeFields">
            <summary>
            Gets a value indicating whether fields should be considered.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.#ctor(FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Creates an instance of the equivalency assertions options based on defaults previously configured by the caller.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#IsValueType(System.Type)">
            <summary>
            Gets a value indicating whether the <paramref name="type"/> should be treated as having value semantics.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllDeclaredProperties">
            <summary>
            Causes inclusion of only public properties of the subject as far as they are defined on the declared type. 
            </summary>
            <remarks>
            This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllRuntimeProperties">
            <summary>
             Causes inclusion of only public properties of the subject based on its run-time type rather than its declared type.
            </summary>
            <remarks>
             This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingFields">
            <summary>
             Instructs the comparison to include fields. 
            </summary>
            <remarks>
             This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingFields">
            <summary>
             Instructs the comparison to exclude fields. 
            </summary>
            <remarks>
             This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingProperties">
            <summary>
             Instructs the comparison to include properties.  
            </summary>
            <remarks>
             This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingProperties">
            <summary>
             Instructs the comparison to exclude properties. 
            </summary>
            <remarks>
             This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingRuntimeTypes">
            <summary>
            Instructs the comparison to respect the subject's runtime type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingDeclaredTypes">
            <summary>
            Instructs the comparison to respect the subject's declared type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.ISubjectInfo,System.Boolean}})">
            <summary>
            Excludes a (nested) property based on a predicate from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingMissingProperties">
            <summary>
            Tries to match the properties of the subject with equally named properties on the expectation. Ignores those 
            properties that don't exist on the expectation and previously registered matching rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingMissingMembers">
            <summary>
            Tries to match the members of the subject with equally named members on the expectation. Ignores those 
            members that don't exist on the expectation and previously registered matching rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ThrowingOnMissingProperties">
            <summary>
            Requires the expectation to have properties which are equally named to properties on the subject.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ThrowingOnMissingMembers">
            <summary>
            Requires the expectation to have members which are equally named to members on the subject.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using``1(System.Action{FluentAssertions.Equivalency.IAssertionContext{``0}})">
            <param name="action">
            The assertion to execute when the predicate is met.
            </param>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingNestedObjects">
            <summary>
            Causes the structural equality check to include nested collections and complex types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingNestedObjects">
            <summary>
            Causes the structural equality check to exclude nested collections and complex types.
            </summary>
            <remarks>
            Behaves similarly to the old property assertions API.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IgnoringCyclicReferences">
            <summary>
            Causes the structural equality check to ignore any cyclic references.
            </summary>
            <remarks>
            By default, cyclic references within the object graph will cause an exception to be thrown.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.AllowingInfiniteRecursion">
            <summary>
            Disables limitations on recursion depth when the structural equality check is configured to include nested objects
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutSelectionRules">
            <summary>
            Clears all selection rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutMatchingRules">
            <summary>
            Clears all matching rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberSelectionRule)">
            <summary>
            Adds a selection rule to the ones already added by default, and which is evaluated after all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberMatchingRule)">
            <summary>
            Adds a matching rule to the ones already added by default, and which is evaluated before all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.ISelectionRule)">
            <summary>
            Adds a selection rule to the ones already added by default, and which is evaluated after all existing rules.
            </summary>
            <remarks>
            Using this method will cause all fields to be excluded. 
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMatchingRule)">
            <summary>
            Adds a matching rule to the ones already added by default, and which is evaluated before all existing rules.
            </summary>
            <remarks>
            Using this method will cause all fields to be excluded. 
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IAssertionRule)">
            <summary>
            Adds an assertion rule to the ones already added by default, and which is evaluated before all existing rules.
            NOTE: These assertion rules do not apply to the root object.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IEquivalencyStep)">
            <summary>
            Adds an equivalency step rule to the ones already added by default, and which is evaluated before previous user-registered steps
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrdering">
            <summary>
            Causes all collections to be compared in the order in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.ISubjectInfo,System.Boolean}})">
            <summary>
            Causes the collection identified by the provided <paramref name="predicate"/> to be compared in the order 
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByName">
            <summary>
            Causes to compare Enum properties using the result of their ToString method.
            </summary>
            <remarks>
            By default, enums are compared by value.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByValue">
            <summary>
            Causes to compare Enum members using their underlying value only.
            </summary>
            <remarks>
            This is the default.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByValue``1">
            <summary>
            Marks the <typeparamref name="T"/> as a value type which must be compared using its 
            <see cref="M:System.Object.Equals(System.Object)"/> method.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#SelectionRules">
            <summary>
            Gets an ordered collection of selection rules that define what members are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#MatchingRules">
            <summary>
            Gets an ordered collection of matching rules that determine which subject members are matched with which
            expectation members.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#UserEquivalencySteps">
            <summary>
            Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#OrderingRules">
            <summary>
            Gets an ordered collection of rules that determine whether or not the order of collections is important. By default,
            ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#IsRecursive">
            <summary>
            Gets value indicating whether the equality check will include nested collections and complex types.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#CyclicReferenceHandling">
            <summary>
            Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1">
            <summary>
            Defines additional overrides when used with <see cref="!:EquivalencyAssertionOptions.When"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.WhenTypeIs``1">
            <summary>
            Allows overriding the way structural equality is applied to (nested) objects of type <typeparamref name="TMemberType"/>
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.When(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.ISubjectInfo,System.Boolean}})">
            <summary>
            Allows overriding the way structural equality is applied to particular members.
            </summary>
            <param name="predicate">
            A predicate based on the <see cref="T:FluentAssertions.Equivalency.ISubjectInfo"/> of the subject that is used to identify the property for which the
            override applies.
            </param>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptionsExtentions.GetSubjectType(FluentAssertions.Equivalency.IEquivalencyAssertionOptions,FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
                Returns either the run-time or compile-time type of the subject based on the options provided by the caller.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.FieldSelectedMemberInfo">
            <summary>
            Provides an ISelectedMemberInfo for FieldInfo objects
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.MemberInfoSelectedMemberInfo">
            <summary>
            A partial ISelectedMemberInfo implementation that delegates to a MemberInfo object
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelectedMemberInfo">
            <summary>
            Exposes information about an object's member
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelectedMemberInfo.GetValue(System.Object,System.Object[])">
            <summary>
            Returns the member value of a specified object with optional index values for indexed properties or methods.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.Name">
            <summary>
            Gets the name of the current member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.MemberType">
            <summary>
            Gets the type of this member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.DeclaringType">
            <summary>
            Gets the class that declares this member.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMatchingRule">
            <summary>
            Represents a rule that defines how to map the properties from the subject-under-test with the properties 
            on the expectation object. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMatchingRule.Match(System.Reflection.PropertyInfo,System.Object,System.String)">
            <summary>
            Attempts to find a property on the expectation that should be compared with the 
            <paramref name="subjectProperty"/> during a structural equality.
            </summary>
            <remarks>
            Whether or not a match is required or optional is up to the specific rule. If no match is found and this is not an issue,
            simply return <c>null</c>.
            </remarks>
            <param name="subjectProperty">
            The <see cref="T:System.Reflection.PropertyInfo"/> of the subject's property for which a match must be found. Can never
            be <c>null</c>.
            </param>
            <param name="expectation">
            The expectation object for which a matching property must be returned. Can never be <c>null</c>.
            </param>
            <param name="propertyPath">
            The dotted path from the root object to the current property. Will never  be <c>null</c>.
            </param>
            <returns>
            Returns the <see cref="T:System.Reflection.PropertyInfo"/> of the property with which to compare the subject with, or <c>null</c>
            if no match was found.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that includes a particular member in the structural comparison.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.GenericDictionaryEquivalencyStep">
            <remarks>
            I think (but did not try) this would have been easier using 'dynamic' but that is
            precluded by some of the PCL targets.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.ISelectionRule">
            <summary>
            Represents a rule that defines which properties of the subject-under-test to include while comparing
            two objects for structural equality.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ISelectionRule.SelectProperties(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Adds or removes properties to/from the collection of subject properties that must be included while
            comparing two objects for structural equality.
            </summary>
            <param name="selectedProperties">
            A collection of properties that was prepopulated by other selection rules. Can be empty.</param>
            <param name="info">
            Type info about the subject.
            </param>
            <returns>
            The collection of properties after applying this rule. Can contain less or more than was passed in.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.PropertySelectedMemberInfo">
            <summary>
            Provides an ISelectedMemberInfo for PropertyInfo objects
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.RunAllUserStepsEquivalencyStep">
            <summary>
            Represents a composite equivalency step that passes the execution to all user-supplied steps that can handle the 
            current context.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.StringEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.StringEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.ValueTypeEquivalencyStep">
            <summary>
            Ensures that types that are marked as value types are treated as such.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ValueTypeEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ValueTypeEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Execution.Continuation">
            <summary>
            Enables chaining multiple assertions on an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.Continuation.op_Implicit(FluentAssertions.Execution.Continuation)~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Continuation.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.MessageBuilder">
            <summary>
            Encapsulates expanding the various placeholders supported in a failure message. 
            </summary>
        </member>
        <member name="F:FluentAssertions.Execution.MessageBuilder.ReasonTag">
            <summary>
            Represents the phrase that can be used in <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> as a placeholder for the reason of an assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContinuationOfGiven`1">
            <summary>
            Enables chaining multiple assertions from a <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> call.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuationOfGiven`1.op_Implicit(FluentAssertions.Execution.ContinuationOfGiven{`0})~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.ContinuationOfGiven`1.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.GivenSelector`1">
            <summary>
            Represents a chaining object returned from <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> to continue the assertion using
            an object returned by a selector.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.ForCondition(System.Func{`0,System.Boolean})">
            <summary>
            Specify the condition that must be satisfied upon the subject selected through a prior selector.
            </summary>
            <param name="condition">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
            <remarks>
            The condition will not be evaluated if the prior assertion failed, nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/>
            throw any exceptions.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.Given``1(System.Func{`0,``0})">
            <summary>
            Allows to safely refine the subject for successive assertions, even when the prior assertion has failed.
            </summary>
            <paramref name="selector">
            Selector which result is passed to successive calls to <see cref="M:FluentAssertions.Execution.GivenSelector`1.ForCondition(System.Func{`0,System.Boolean})"/>.
            </paramref>
            <remarks>
            The selector will not be invoked if the prior assertion failed, nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/>
            throw any exceptions.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String)">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a 
            prior call to to <see cref="!:WithExpectation"/>.
            </summary>
            <remarks>
            If an expectation was set through a prior call to <see cref="!:WithExpectation"/>, then the failure message is appended to that
            expectation. 
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a 
            prior call to to <see cref="!:WithExpectation"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few 
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed 
            to <see cref="!:BecauseOf"/>. Other named placeholders will be replaced with the <see cref="!:Current"/> scope data 
            passed through <see cref="!:AddNonReportable"/> and <see cref="!:AddReportable"/>. Finally, a description of the 
            current subject can be passed through the {context:description} placeholder. This is used in the message if no 
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor. 
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="!:WithExpectation"/>, then the failure message is appended to that
            expectation. 
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Object[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a 
            prior call to to <see cref="!:WithExpectation"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few 
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed 
            to <see cref="!:BecauseOf"/>. Other named placeholders will be replaced with the <see cref="!:Current"/> scope data 
            passed through <see cref="!:AddNonReportable"/> and <see cref="!:AddReportable"/>. Finally, a description of the 
            current subject can be passed through the {context:description} placeholder. This is used in the message if no 
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor. 
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="!:WithExpectation"/>, then the failure message is appended to that
            expectation. 
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="T:FluentAssertions.InternalAssertionExtensions">
            <summary>
            Contains extension methods for custom assertions in unit tests.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Invoking``1(``0,System.Action{``0})">
            <summary>
            Invokes the specified action on an subject so that you can chain it with any of the ShouldThrow or ShouldNotThrow 
            overloads.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Enumerating(System.Func{System.Collections.IEnumerable})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the 
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Enumerating``1(System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the 
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Object)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.ObjectAssertions"/> object that can be used to assert the
            current <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Boolean)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.BooleanAssertions"/> object that can be used to assert the
            current <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Boolean})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableBooleanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Guid)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.GuidAssertions"/> object that can be used to assert the
            current <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Guid})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableGuidAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Collections.IEnumerable)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.NonGenericCollectionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericCollectionAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.StringCollectionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericDictionaryAssertions`2"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.DateTime)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.DateTimeOffsetAssertions"/> object that can be used to assert the
            current <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.DateTime})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should``1(System.IComparable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.ComparableTypeAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.IComparable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Int32)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Int32})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Decimal)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Decimal})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Byte)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Byte})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Int16)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Int16})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Int64)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Int64})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Single)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Single})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Double)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.Double})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.String)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.StringAssertions"/> object that can be used to assert the
            current <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.TimeSpan)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions"/> object that can be used to assert the
            current <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Nullable{System.TimeSpan})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Type)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Reflection.MethodInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoAssertions"/> object that can be used to assert the current <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(FluentAssertions.Types.MethodInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> object that can be used to assert the methods returned by the
            current <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(System.Reflection.PropertyInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoAssertions"/> object that can be used to assert the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.Should(FluentAssertions.Types.PropertyInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoAssertions"/> object that can be used to assert the properties returned by the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.ShouldBeEquivalentTo``1(``0,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object. 
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value, 
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal. 
            Notice that actual behavior is determined by the <see cref="!:EquivalencyAssertionOptions.Default"/> instance of the 
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions"/> class.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the 
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.ShouldBeEquivalentTo``1(``0,System.Object,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object. 
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value, 
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal. 
            </remarks>
            <param name="config">
            A reference to the <see cref="!:EquivalencyAssertionOptions.Default"/> configuration object that can be used 
            to influence the way the object graphs are compared. You can also provide an alternative instance of the 
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the 
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.InternalAssertionExtensions.As``1(System.Object)">
            <summary>
            Safely casts the specified object to the type specified through <typeparamref name="TTo"/>.
            </summary>
            <remarks>
            Has been introduced to allow casting objects without breaking the fluent API.
            </remarks>
            <typeparam name="TTo"></typeparam>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInAscendingOrder(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the the specified 
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInDescendingOrder(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the the specified 
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Collections.GenericDictionaryAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.Generic.IDictionary`2"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary matches the supplied <paramref name="expected"/> amount.
            </summary>
            <param name="expected">The expected number of items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary matches a condition stated by a predicate.
            </summary>
            <param name="countPredicate">The predicate which must be satisfied by the amount of items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Equal(System.Collections.Generic.IDictionary{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains all the same key-value pairs as the
            specified <paramref name="expected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotEqual(System.Collections.Generic.IDictionary{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts the current dictionary not to contain all the same key-value pairs as the
            specified <paramref name="unexpected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="unexpected">The unexpected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKey(`0,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified key. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKeys(`0[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected keys</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKeys(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected keys</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainKey(`0,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected"/> key.
            Keys are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="unexpected">The unexpected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValue(`1,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified value. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValues(`1[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected values</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValues(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected values</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.RepetitionPreservingIntersect(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Returns an enumerable consisting of all items in the first collection also appearing in the second.
            </summary>
            <remarks>Enumerable.Intersect is not suitable because it drops any repeated elements.</remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainValue(`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected"/> value.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(System.Collections.Generic.KeyValuePair{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(`0,`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="value"/> for the supplied <paramref name="key"/>. Values are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(System.Collections.Generic.KeyValuePair{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="item"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="item">The unexpected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(`0,`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="value"/> for the
            supplied <paramref name="key"/>. Values are compared using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.GenericDictionaryAssertions`2.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.NonGenericCollectionAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.IEnumerable"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches the supplied <paramref name="expected"/> amount.
            </summary>
            <param name="expected">The expected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches a condition stated by the <paramref name="countPredicate"/>.
            </summary>
            <param name="countPredicate">A predicate that yields the number of items that is expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.Contain(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection contains the specified <paramref name="expected"/> object. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An object, or <see cref="T:System.Collections.IEnumerable"/> of objects that are expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Equal(System.String[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by 
            <paramref name="expected"/>. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Equal(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by 
            <paramref name="expected"/>. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.BeEquivalentTo(System.String[])">
            <summary>
            Expects the current collection to contain all elements of the collection identified by <paramref name="elements"/>,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.BeEquivalentTo(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain all elements of the collection identified by <paramref name="expected"/>,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.ContainInOrder(System.String[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.ContainInOrder(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">An <see cref="!:IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Asserts that the collection contains some extra items in addition to the original items.
            </summary>
            <param name="expectedItemsList">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of expectation items.</param>
            <param name="additionalExpectedItems">Additional items that are expectation to be contained by the collection.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Asserts that the collection contains some extra items in addition to the original items.
            </summary>
            <param name="expectedItemsList">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of expectation items.</param>
            <param name="additionalExpectedItems">Additional items that are expectation to be contained by the collection.</param>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.Current">
            <summary>
            Gets the active configuration,
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode">
            <summary>
            Gets or sets the mode on how Fluent Assertions will find custom implementations of 
            <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly">
            <summary>
            Gets or sets the assembly name to scan for custom value formatters in case <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>
            is set to <see cref="!:ValueFormatterDetectionMode.Specific"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.ExpressionExtensions.GetMemberPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets a dotted path of property names representing the property expression. E.g. Parent.Child.Sibling.Name.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Services">
            <summary>
            Maintains the framework-specific services.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexOfFirstMismatch(System.String,System.String)">
            <summary>
            Finds the first index at which the <paramref name="value"/> does not match the <paramref name="expected"/>
            string anymore, including the exact casing.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexOfFirstMismatch(System.String,System.String,System.StringComparison)">
            <summary>
            Finds the first index at which the <paramref name="value"/> does not match the <paramref name="expected"/>
            string anymore, accounting for the specified <paramref name="stringComparison"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexedSegmentAt(System.String,System.Int32)">
            <summary>
            Gets the quoted three characters at the specified index of a string, including the index itself.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Escape(System.String)">
            <summary>
            Replaces all characters that might conflict with formatting placeholders and newlines with their escaped counterparts.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Combine(System.String,System.String,System.String)">
            <summary>
            Joins a string with one or more other strings using a specified separator.
            </summary>
            <remarks>
            Any string that is empty (including the original string) is ignored. 
            </remarks>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Capitalize(System.String)">
            <summary>
            Changes the first character of a string to uppercase.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Determines whether the specified method has been annotated with a specific attribute.
            </summary>
            <returns>
              <c>true</c> if the specified method has attribute; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsEquivalentTo(FluentAssertions.Equivalency.SelectedMemberInfo,FluentAssertions.Equivalency.SelectedMemberInfo)">
            <summary>
            Determines whether two <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> objects refer to the same member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            NOTE: This method does not give the expected results with open generics
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindMember(System.Type,System.String,System.Type)">
            <summary>
            Finds a member by its case-sensitive name.
            </summary>
            <returns>
            Returns <c>null</c> if no such member exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindProperty(System.Type,System.String,System.Type)">
            <summary>
            Finds the property by a case-sensitive name.
            </summary>
            <returns>
            Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindField(System.Type,System.String,System.Type)">
            <summary>
            Finds the field by a case-sensitive name.
            </summary>
            <returns>
            Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="T:FluentAssertions.Common.ValueFormatterDetectionMode">
            <summary>
            Defines the modes in which custom implementations of <see cref="!:IValueFormatter"/> are detected as configured
            through <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Disabled">
            <summary>
            Detection is disabled.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Specific">
            <summary>
            Only custom value formatters exposed through the assembly set in <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly"/>
            are detected.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Scan">
            <summary>
            All custom value formatters in any assembly loaded in the current <see cref="!:AppDomain"/> will be detected.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllPublicPropertiesSelectionRule">
            <summary>
            Selection rule that adds all public properties of the subject.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllPublicPropertiesSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionResultSet">
            <summary>
            Represents a collection of assertion results obtained through a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionResultSet.AddSet(System.Object,System.String[])">
            <summary>
            Adds the failures (if any) resulting from executing an assertion within a
             <see cref="T:FluentAssertions.Execution.AssertionScope"/> identified by a key. 
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionResultSet.SelectClosestMatchFor(System.Object)">
            <summary>
            Returns  the closest match compared to the set identified by the provided <paramref name="key"/> or
            an empty array if one of the results represents a successful assertion. 
            </summary>
            <remarks>
             The closest match is the set that contains the least amount of failures, or no failures at all, and preferably 
            the set that is identified by the <paramref name="key"/>.        
            </remarks>
        </member>
        <member name="P:FluentAssertions.Equivalency.AssertionResultSet.ContainsSuccessfulSet">
            <summary>
            Gets a value indicating whether this collection contains a set without any failures at all.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionRule`1">
            <summary>
            General purpose implementation of <see cref="T:FluentAssertions.Equivalency.IAssertionRule"/> that uses a predicate to determine whether
            this rule applies to a particular property and executes an action to assert equality.
            </summary>
            <typeparam name="TSubject">The type of the subject.</typeparam>
        </member>
        <member name="M:FluentAssertions.Equivalency.IAssertionRule.AssertEquality(FluentAssertions.Equivalency.IEquivalencyValidationContext)">
            <summary>
            Defines how a subject's property is compared for equality with the same property of the expectation.
            </summary>
            <returns>
            Returns <c>true</c> if the rule was applied correctly and the assertion didn't cause any exceptions. 
            Returns <c>false</c> if this rule doesn't support the subject's type.
            Throws if the rule did support the data type but assertion fails.
            </returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRule`1.AssertEquality(FluentAssertions.Equivalency.IEquivalencyValidationContext)">
            <summary>
            Defines how a subject's property is compared for equality with the same property of the expectation.
            </summary>
            <param name="subjectProperty">
            Provides details about the subject's property.
            </param>
            <param name="subject">
            The value of the subject's property.
            </param>
            <param name="expectation">
            The value of a property on expectation object that was identified 
            </param>
            <returns>
            Returns <c>true</c> if the rule was applied correctly and the assertion didn't cause any exceptions. 
            Returns <c>false</c> if this rule doesn't support the subject's type.
            Throws if the rule did support the data type but assertion fails.
            </returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRule`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.ByteArrayOrderingRule">
            <summary>
            Ordering rule that ensures that byte arrays are always compared in strict ordering since it would cause a 
            severe performance impact otherwise.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.StructuralEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.CyclicReferenceHandling">
            <summary>
            Indication of how cyclic references should be handled when validating equality of nested properties.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.Ignore">
            <summary>
            Cyclic references will be ignored.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.ThrowException">
            <summary>
            Cyclic references will result in an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.DictionaryEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.DictionaryEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.GenericEnumerableEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the verificationScope subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.GenericEnumerableEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.EnumerableEquivalencyValidator">
            <summary>
            Executes a single equivalency assertion on two collections, optionally recursive and with or without strict ordering.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1">
            <summary>
            Represents the run-time type-specific behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Empty">
            <summary>
            Gets a configuration that by default doesn't include any of the subject's members and doesn't consider any nested objects
            or collections.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Default">
            <summary>
            Gets a configuration that compares all declared members of the subject with equally named members of the expectation,
            and includes the entire object graph. The names of the members between the subject and expectation must match.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Excludes the specified (nested) member from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.ISubjectInfo,System.Boolean}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Causes the collection identified by <paramref name="expression"/> to be compared in the order 
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.AsCollection">
            <summary>
            Creates a new set of options based on the current instance which acts on a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions">
            <summary>
            Represents the run-time type-agnostic behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyValidationContext">
            <summary>
            Provides information on a particular property during an assertion for structural equality of two object graphs.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Expectation">
            <summary>
            Gets the value of the <see cref="!:MatchingExpectationProperty"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Reason">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.ReasonArgs">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.IsRoot">
            <summary>
            Gets a value indicating whether the current context represents the root of the object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Subject">
            <summary>
            Gets the value of the <see cref="!:ISelectionContext.PropertyInfo"/>
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.RootIsCollection">
            <summary>
            Gets or sets a value indicating that the root of the graph is a collection so all type-specific options apply on 
            the collection type and not on the root itself.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Subject">
            <summary>
            Gets the value of the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.SelectedMemberInfo"/>
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Expectation">
            <summary>
            Gets the value of the <see cref="!:IEquivalencyValidationContext.MatchingExpectationProperty"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Reason">
            <summary>
              A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
              is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.ReasonArgs">
            <summary>
              Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Reason"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.IsRoot">
            <summary>
              Gets a value indicating whether the current context represents the root of the object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object and the type is not <see cref="T:System.Object"/>, 
            then it returns the same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.RootIsCollection">
            <summary>
            Gets or sets a value indicating that the root of the graph is a collection so all type-specific options apply on 
            the collection type and not on the root itself.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyValidator">
            <summary>
            Is responsible for validating the equality of one or more properties of a subject with another object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPathSelectionRule">
            <summary>
            Selection rule that removes a particular property from the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that removes a particular member from the structural comparison based on a predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPathSelectionRule">
            <summary>
            Selection rule that includes a particular property in the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule">
            <summary>
            An ordering rule that basically states that the order of items in all collections is important.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule.AppliesTo(FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="subjectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.MustMatchByNameRule">
            <summary>
            Requires the expectation object to have a member with the exact same name.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.MustMatchByNameRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.NestedSelectionContext">
            <summary>
            Represents a selection context of a nested property
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Selection.NestedSelectionContext.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object, then it returns the 
            same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.ISubjectInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Selection.NestedSelectionContext.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.ObjectReference">
            <summary>
            Represents  an object tracked by the <see cref="T:FluentAssertions.Equivalency.ObjectTracker"/> including it's location within an object graph.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectReference.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectReference.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.ObjectTracker">
            <summary>
            Keeps track of objects and their location within an object graph so that cyclic references can be detected
            and handled upon.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ICloneable2">
            <summary>
            Custom version of ICloneable that works on all frameworks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ICloneable2.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectTracker.IsCyclicReference(FluentAssertions.Equivalency.ObjectReference)">
            <summary>
            Determines whether the specified object reference is a cyclic reference to the same object earlier in the 
            equivalency validation.
            </summary>
            <remarks>
            The behavior of a cyclic reference is determined by the <see cref="T:FluentAssertions.Equivalency.CyclicReferenceHandling"/> constructor
            parameter.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectTracker.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.OrderingRuleCollection">
            <summary>
            Collection of <see cref="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule"/>s.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor">
            <summary>
            Initializes a new collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor(System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.IOrderingRule})">
            <summary>
            Initializes a new collection of ordering rules based on an existing collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.IsOrderingStrictFor(FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Determines whether the rules in this collection dictate strict ordering during the equivalency assertion on
            the collection pointed to by <paramref name="subjectInfo"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.PredicateBasedOrderingRule.AppliesTo(FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="subjectInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule">
            <summary>
            Represents a rule for determining whether or not a certain collection within the object graph should be compared using
            strict ordering.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule.AppliesTo(FluentAssertions.Equivalency.ISubjectInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="subjectInfo"/> is relevant.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ReferenceEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ReferenceEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.TryConversionEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.TryConversionEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.TryMatchByNameRule">
            <summary>
            Finds a member of the expectation with the exact same name, but doesn't require it.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.TryMatchByNameRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Events.EventMonitor">
            <summary>
            
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventMonitor.GetRecorderForEvent``1(``0,System.String)">
            <summary>
            Obtains the <see cref="T:FluentAssertions.Events.EventRecorder"/> for a particular event of the <paramref name="eventSource"/>.
            </summary>
            <param name="eventSource">The object for which to get an event recorder.</param>
            <param name="eventName">The name of the event.</param>
            <returns></returns>
        </member>
        <member name="T:FluentAssertions.Events.EventRecorder">
            <summary>
              Records activity for a single event.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.IEventRecorder">
            <summary>
              Records raised events for one event on one object
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IEventRecorder.RecordEvent(System.Object[])">
            <summary>
              Store information about a raised event
            </summary>
            <param name = "parameters">Parameters the event was raised with</param>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecorder.EventObject">
            <summary>
              The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecorder.EventName">
            <summary>
              The name of the event that's recorded
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.#ctor(System.Object,System.String)">
            <summary>
            </summary>
            <param name = "eventRaiser">The object events are recorded from</param>
            <param name = "eventName">The name of the event that's recorded</param>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.GetEnumerator">
            <summary>
              Enumerate raised events
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Enumerate raised events
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.RecordEvent(System.Object[])">
            <summary>
              Called by the auto-generated IL, to record information about a raised event.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventObject">
            <summary>
              The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventName">
            <summary>
              The name of the event that's recorded
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventRecordersMap">
            <summary>
                Simple dictionary that uses a <see cref="T:System.WeakReference"/> to the event source as the key. 
                This should ensure the Garbage Collector can still clean-up the event source object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.RecordedEvent">
            <summary>
            This class is used to store data about an intercepted event
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.RecordedEvent.#ctor(System.Object,System.Object[])">
            <summary>
            Default constructor stores the parameters the event was raised with
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.Parameters">
            <summary>
            Parameters for the event
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.AssertionScope">
            <summary>
            Represents an implicit or explicit scope within which multiple assertions can be collected.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor">
            <summary>
            Starts an unnamed scope within which multiple assertions can be executed and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(System.String)">
            <summary>
            Starts a named scope within which multiple assertions can be executed and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(FluentAssertions.Execution.AssertionScope,System.Boolean)">
            <summary>
            Creates a nested scope used during chaining.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])">
            <summary>
            Specify the reason why you expect the condition to be <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase explaining why the condition should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])">
            <summary>
            Sets the expectation part of the failure message when the assertion is not met. 
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few 
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed 
            to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data 
            passed through <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the 
            current subject can be passed through the {context:description} placeholder. This is used in the message if no 
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor. 
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure message is appended to that
            expectation. 
            </remarks>
             <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})">
            <summary>
            Allows to safely select the subject for successive assertions, even when the prior assertion has failed.
            </summary>
            <paramref name="selector">
            Selector which result is passed to successive calls to <see cref="M:FluentAssertions.Execution.AssertionScope.ForCondition(System.Boolean)"/>.
            </paramref>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.ForCondition(System.Boolean)">
            <summary>
            Specify the condition that must be satisfied.
            </summary>
            <param name="condition">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a 
            prior call to to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few 
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed 
            to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data 
            passed through <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the 
            current subject can be passed through the {context:description} placeholder. This is used in the message if no 
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor. 
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure message is appended to that
            expectation. 
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Discard">
            <summary>
            Discards and returns the failures that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Get``1(System.String)">
            <summary>
            Gets data associated with the current scope and identified by <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Current">
            <summary>
            Gets the current thread-specific assertion scope. 
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.UsingLineBreaks">
            <summary>
            Indicates that every argument passed into <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> is displayed on a separate line.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Succeeded">
            <summary>
            Gets a value indicating whether or not the last assertion executed through this scope succeeded.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.IAssertionStrategy">
            <summary>
            Defines a strategy for handling failures in a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.IAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.CollectingAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContextDataItems">
            <summary>
            Represents a collection of data items that are associated with an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.DefaultAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Execute">
            <summary>
            Helper class for verifying a condition and/or throwing a test harness specific exception representing an assertion failure.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Execute.Assertion">
            <summary>
            Gets an object that wraps and executes a conditional or unconditional assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Reportability">
            <summary>
            Determines whether data associated with an <see cref="T:FluentAssertions.Execution.AssertionScope"/> should be included in the assertion failure.
            </summary>
        </member>
        <member name="T:FluentAssertions.FluentDateTimeExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </summary>
            <example>
            Instead of<br/>
            <br/>
            new DateTime(2011, 3, 10)<br/>
            <br/>
            you can write 3.March(2011)<br/>
            <br/>
            Or even<br/>
            <br/>
            3.March(2011).At(09, 30)
            </example>
            <seealso cref="T:FluentAssertions.TimeSpanConversionExtensions"/>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.January(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month January.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.February(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month February.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.March(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month March.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.April(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month April.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.May(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month May.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.June(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month June.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.July(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month July.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.August(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month August.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.September(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month September.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.October(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month October.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.November(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month November.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.December(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month December.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.At(System.DateTime,System.TimeSpan)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and <paramref name="time"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.At(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.At(System.DateTimeOffset,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.Before(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> before the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.FluentDateTimeExtensions.After(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> after the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.AggregateExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.AggregateExceptionValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.AttributeBasedFormatter">
            <summary>
            Specialized value formatter that looks for static methods in the caller's assembly marked with the 
            <see cref="T:FluentAssertions.Formatting.ValueFormatterAttribute"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.AttributeBasedFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.AttributeBasedFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DateTimeOffsetValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DateTimeOffsetValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.CanHandle(System.Object)">
            <summary>
              Determines whether this instance can handle the specified value.
            </summary>
            <param name = "value">The value.</param>
            <returns>
              <c>true</c> if this instance can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumerableValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumerableValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExceptionValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExpressionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExpressionValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.Formatter">
            <summary>
            Provides services for formatting an object being used in an assertion in a human readable format.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a human-readable representation of a particular object.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="nestedPropertyLevel">
                The level of nesting for the supplied value. This is used for indenting the format string for objects that have
                no <see cref="M:System.Object.ToString"/> override.
            </param>
            <param name="useLineBreaks">
            Indicates whether the formatter should use line breaks when the specific <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> supports it.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.RemoveFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Removes a custom formatter that was previously added though <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Ensures a custom formatter is included in the chain, just before the default formatter is executed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.AddPlatformFormatters(FluentAssertions.Formatting.IValueFormatter[])">
            <summary>
            Allows a platform-specific assembly to add formatters without affecting the ones added by callers of <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </summary>
            <param name="formatters"></param>
        </member>
        <member name="P:FluentAssertions.Formatting.Formatter.Formatters">
            <summary>
            A list of objects responsible for formatting the objects represented by placeholders.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.GuidValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.GuidValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NullValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NullValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NumericValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NumericValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.PropertyInfoFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.PropertyInfoFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.StringValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.StringValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.TimeSpanValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.TimeSpanValueFormatter.ToString(System.Object,System.Boolean,System.Collections.Generic.IList{System.Object},System.Int32)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that 
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.ValueFormatterAttribute">
            <summary>
            Marks a static method as a kind of <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> for a particular type.
            </summary>
        </member>
        <member name="T:FluentAssertions.NumericAssertionsExtensions">
            <summary>
            Contains a number of extension methods for floating point <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Numeric.ComparableTypeAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is considered equal to another object according to the implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is not equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeLessOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeGreaterOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value. 
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Numeric.ComparableTypeAssertions`1.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Numeric.NumericAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.Be(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBe(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeLessOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeGreaterOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value. 
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeOneOf(`0[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>  
        </member>
        <member name="T:FluentAssertions.Primitives.BooleanAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.BeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.BeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.Be(System.Boolean,System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.BooleanAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTime"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.Be(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBe(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> or <see cref="T:System.DateTime"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeCloseTo(System.DateTime,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions.Be(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOnOrBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOnOrAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/> 
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should exceed compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/> 
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be equal or exceed compared to
            another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/> 
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should differ exactly compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/> 
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be within another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>   
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTime"/>  should differ compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTimeOffset"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.Be(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBe(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeCloseTo(System.DateTimeOffset,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.Be(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOnOrBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOnOrAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should exceed compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be equal or exceed compared to
            another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ exactly compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be within another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>  
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeOffsetAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> and <see cref="T:FluentAssertions.TimeSpanConversionExtensions"/> for a more fluent
            way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions.Before(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time before another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions.After(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time after another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.GuidAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Guid"/> is in the correct state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected <see cref="T:System.String"/> value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.Be(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.NotBe(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not equal to the <paramref name="unexpected"/> GUID.
            </summary>
            <param name="unexpected">The unexpected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.GuidAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.StringValidator">
            <summary>
            Dedicated class for comparing two strings and generating consistent error messages.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableBooleanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.Be(System.Nullable{System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotBeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotBeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTime"/> or <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.Be(System.Nullable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.Be(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableGuidAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Guid"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.Be(System.Nullable{System.Guid},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.TimeSpanConversionExtensions"/> for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Be(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is equal to the 
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The expected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBe(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is not equal to the 
            specified <paramref name="unexpected"/> time.
            </summary>
            <param name="unexpected">The unexpected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeLessThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than the 
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeLessOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than or equal to the 
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeGreaterThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than the 
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeGreaterOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than or equal to the 
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeCloseTo(System.TimeSpan,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Be(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="expected"></param>
            <param name="i"></param>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>      
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.Be(System.Nullable{System.TimeSpan},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.ObjectAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Object"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.Be(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that an object equals another object using its <see cref="M:System.Object.Equals(System.Object)"/> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.NotBe(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that an object does not equal another object using its <see cref="M:System.Object.Equals(System.Object)"/> method.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.HaveFlag(System.Enum,System.String,System.Object[])">
            <summary>
            Asserts that an object is an enum and has a specified flag
            </summary>
            <param name="expectedFlag">The expected flag.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.NotHaveFlag(System.Enum,System.String,System.Object[])">
            <summary>
            Asserts that an object is an enum and does not have a specified flag
            </summary>
            <param name="unexpectedFlag">The unexpected flag.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.ObjectAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.StringAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.String"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The expected string.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeOneOf(System.String[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeEquivalentTo(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including any leading or trailing whitespace, with 
            the exception of the casing.
            </summary>
            <param name="expected">
            The string that the subject is expected to be equivalent to.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBe(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is not exactly the same as the specified <paramref name="unexpected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to be equivalent to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Match(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatch(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.MatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.MatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.StartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts exactly with the specified <paramref name="expected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotStartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.StartWithEquivalent(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotStartWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.EndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends exactly with the specified <paramref name="expected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotEndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end exactly with the specified <paramref name="unexpected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.EndWithEquivalent(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotEndWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end with the specified <paramref name="unexpected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Contain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains another (fragment of a) string.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain another (fragment of a) string.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should not contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain the specified <paramref name="unexpected"/> string,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is not <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.HaveLength(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that a string has the specified <paramref name="expected"/> length.
            </summary>
            <param name="expected">The expected length of the string</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/> nor white space
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/> or white space
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.StringAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.Negate">
            <summary>
            Gets or sets a value indicating whether the subject should not match the pattern.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreCase">
            <summary>
            Gets or sets a value indicating whether the matching process should ignore any casing difference.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreNewLineDifferences">
            <summary>
            Ignores the difference between environment newline differences
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeRangeAssertions">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.FluentDateTimeExtensions"/> and <see cref="T:FluentAssertions.TimeSpanConversionExtensions"/> for a more fluent
            way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions.Before(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time before another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions.After(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time after another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.TimeSpanPredicate">
            <summary>
            Provides the logic and the display text for a <see cref="T:FluentAssertions.Primitives.TimeSpanCondition"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.PropertyChangedSourceExtensions">
            <summary>
              Provides extension methods for monitoring and querying events.
            </summary>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.ShouldRaisePropertyChangeFor``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Asserts that an object has raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <remarks>
            You must call <see cref="!:MonitorEvents"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.ShouldRaisePropertyChangeFor``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised, or
            <c>null</c> to refer to all properties.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="!:MonitorEvents"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.ShouldNotRaisePropertyChangeFor``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Asserts that an object has not raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <remarks>
            You must call <see cref="!:MonitorEvents"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.ShouldNotRaisePropertyChangeFor``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has not raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="!:MonitorEvents"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.WithSender(FluentAssertions.Events.IEventRecorder,System.Object)">
            <summary>
            Asserts that all occurrences of the event originated from the <param name="expectedSender"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.PropertyChangedSourceExtensions.WithArgs``1(FluentAssertions.Events.IEventRecorder,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Asserts that at least one occurrence of the event had an <see cref="T:System.EventArgs"/> object matching a predicate.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.ActionAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Action"/> yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.ShouldThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.ShouldNotThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.ShouldNotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Specialized.ActionAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.AsyncFunctionAssertions">
            <summary>
            Contains a number of methods to assert that an asynchronous method yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.ShouldThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.ShouldNotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.ShouldNotThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Specialized.AsyncFunctionAssertions.Subject">
            <summary>
            Gets the <see cref="T:System.Func`1"/> that is being asserted.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.ExceptionAssertions`1">
            <summary>
              Contains a number of methods to assert that an <see cref="T:System.Exception"/> is in the correct state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithMessage(System.String,System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception has a message that matches <paramref name="expectedMessage"/>
              depending on the specified matching mode.
            </summary>
            <param name="expectedMessage">
              The expected message of the exception.
            </param>
            <param name="reason">
              A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
              is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
              Zero or more objects to format using the placeholders in <see cref="!:reason"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerException``1">
            <summary>
              Asserts that the thrown exception contains an inner exception of type <typeparamref name = "TInnerException" />.
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerExceptionExactly``1">
            <summary>
              Asserts that the thrown exception contains an inner exception of the exact type <typeparamref name = "TInnerException" /> (and not a derived exception type).
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerException``1(System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception contains an inner exception of type <typeparamref name = "TInnerException" />.
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
            <param name = "reason">The reason why the inner exception should be of the supplied type.</param>
            <param name = "reasonArgs">The parameters used when formatting the <paramref name = "because" />.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerExceptionExactly``1(System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception contains an inner exception of the exact type <typeparamref name = "TInnerException" /> (and not a derived exception type).
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
            <param name = "reason">The reason why the inner exception should be of the supplied type.</param>
            <param name = "reasonArgs">The parameters used when formatting the <paramref name = "because" />.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerMessage(System.String,System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception contains an inner exception with the <paramref name = "expectedInnerMessage" />.
            </summary>
            <param name = "expectedInnerMessage">The expected message of the inner exception.</param>
            <param name = "reason">
              The reason why the message of the inner exception should match <paramref name = "expectedInnerMessage" />.
            </param>
            <param name = "reasonArgs">The parameters used when formatting the <paramref name = "because" />.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
              Asserts that the exception matches a particular condition.
            </summary>
            <param name="exceptionExpression">
              The condition that the exception must match.
            </param>
            <param name="reason">
              A formatted phrase explaining why the assertion should be satisfied. If the phrase does not 
              start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="reasonArgs">
              Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.And">
            <summary>
              Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Which">
            <summary>
              Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.TimeSpanConversionExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </summary>
            <example>
            Instead of<br/>
            <br/>
            TimeSpan.FromHours(12)<br/>
            <br/>
            you can write<br/>
            <br/>
            12.Hours()<br/>
            <br/>
            Or even<br/>
            <br/>
            12.Hours().And(30.Minutes()).
            </example>
            <seealso cref="T:FluentAssertions.FluentDateTimeExtensions"/>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Ticks(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of ticks.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Milliseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of milliseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Seconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of seconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Seconds(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of seconds, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Minutes(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of minutes.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Minutes(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of minutes, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Hours(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of hours.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Hours(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of hours, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Days(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of days.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.Days(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> based on a number of days, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TimeSpanConversionExtensions.And(System.TimeSpan,System.TimeSpan)">
            <summary>
            Convenience method for chaining multiple calls to the methods provided by this class.
            </summary>
            <example>
            23.Hours().And(59.Minutes())
            </example>
        </member>
        <member name="T:FluentAssertions.TypeEnumerableExtensions">
            <summary>
            Extension methods for filtering a collection of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreDecoratedWith``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreInNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreUnderNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatDeriveFrom``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that subclass the specified type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatImplement``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="T:FluentAssertions.TypeExtensions">
            <summary>
            Extension methods for getting method and property selectors for a type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Reflection.Assembly)">
            <summary>
            Returns the types that are visible outside the specified <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(System.Type)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(System.Type)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.AllTypes">
            <summary>
            Static class that allows for a 'fluent' selection of the types from an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <example>
            AllTypes.From(myAssembly)<br/>
              .ThatImplement&lt;ISomeInterface&gt;<br/>
              .Should()<br/>
              .BeDecoratedWith&lt;SomeAttribute&gt;()
            </example>
        </member>
        <member name="M:FluentAssertions.Types.AllTypes.From(System.Reflection.Assembly)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeSelector"/> for selecting the types that are visible outside the
            specified <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly from which to select the types.</param>
        </member>
        <member name="T:FluentAssertions.Types.MethodBaseAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodBase"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.MemberInfoAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MemberInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodBaseAssertions`2.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected member has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.ConstructorInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.ConstructorInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.ConstructorInfoAssertions.#ctor(System.Reflection.ConstructorInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.ConstructorInfoAssertions"/> class.
            </summary>
            <param name="constructorInfo">The constructorInfo from which to select properties.</param>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is async. 
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.ReturnVoid(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns void.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The expected return type.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelector">
            <summary>
            Allows for fluent selection of methods of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select methods.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select methods.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatReturn``1">
            <summary>
            Only select the methods that return the specified type 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the methods that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.MethodInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.HasSpecialName(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method has a special name (like properties and events).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the methods that are public or internal.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatReturnVoid">
            <summary>
            Only select the methods without a return value
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.MethodInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> class.
            </summary>
            <param name="methodInfo">The methods to assert.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.SubjectMethods">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.PropertyInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected property is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected property returns a specified type.
            </summary>
            <param name="propertyType">The expected type of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected PropertyInfo returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelector">
            <summary>
            Allows for fluent selection of properties of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select properties.</param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select properties.</param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the properties that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.OfType``1">
            <summary>
            Only select the properties that return the specified type 
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the properties that have a public or internal getter.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.PropertyInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelectorAssertions"/> class, for a number of <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
            <param name="properties">The properties to assert.</param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.SubjectProperties">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.TypeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Type"/> meets certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be``1(System.String,System.Object[])">
            <summary>
            Asserts that the current type is equal to the specified <typeparamref name="TExpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type is equal to the specified <paramref name="expected"/> type.
            </summary>
            <param name="expected">The expected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is assignable variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which instances of the type should be assignable.</typeparam>
            <param name="because">The reason why instances of the type should be assignable to the type.</param>
            <param name="reasonArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.GetFailureMessageIfTypesAreDifferent(System.Type,System.Type)">
            <summary>
            Creates an error message in case the specified <paramref name="actual"/> type differs from the 
            <paramref name="expected"/> type.
            </summary>
            <returns>
            An empty <see cref="T:System.String"/> if the two specified types are the same, or an error message that describes that
            the two specified types are not the same.
            </returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe``1(System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <typeparamref name="TUnexpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <paramref name="unexpected"/> type.
            </summary>
            <param name="unexpected">The unexpected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements Interface <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be implemented.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements Interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should be implemented.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement Interface <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be not implemented.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement Interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should not be implemented.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <see cref="T:System.Type"/> <paramref name="baseType"/>.
            </summary>
            <param name="baseType">The Type that should be derived from.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <typeparamref name="TBaseClass"/>.
            </summary>
            <typeparam name="TBaseClass">The Type that should be derived from.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type has a property of type <paramref name="propertyType"/> named <paramref name="name"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="propertyType">The type of the property.</param>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type has a property of type <typeparamref name="TProperty"/> named <paramref name="name"/>.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveProperty(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have a property named <paramref name="name"/>.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a property named 
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a property named 
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a property named 
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a property named 
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a method named <paramref name="name"/> 
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a method named <paramref name="name"/> 
            from interface  <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            /// <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a method named <paramref name="name"/> 
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a method named <paramref name="name"/> 
            from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            /// <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveIndexer(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has an indexer of type <paramref name="indexerType"/>.
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="indexerType">The type of the indexer.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveIndexer(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an indexer that takes parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="parameterTypes">The expected indexer's parameter types.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has a method named <paramref name="name"/>with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="indexerType">The type of the indexer.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not expose a method named <paramref name="name"/>
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The method parameter types.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveConstructor(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has a constructor with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="indexerType">The type of the indexer.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveDefaultConstructor(System.String,System.Object[])">
            <summary>
            Asserts that the current type has a default constructor.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="reasonArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected type has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.TypeAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelector">
            <summary>
            Allows for fluent filtering a list of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Type"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDeriveFrom``1">
            <summary>
            Determines whether a type is a subclass of another type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatImplement``1">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreDecoratedWith``1">
            <summary>
            Determines whether a type is decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreInNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreUnderNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelectorAssertions">
            <summary>
            Contains a number of methods to assert that all <see cref="T:System.Type"/>s in a <see cref="T:FluentAssertions.Types.TypeSelector"/>
            meet certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion 
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.TypeSelectorAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
    </members>
</doc>
