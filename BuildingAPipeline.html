<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="UsingTheContextBag.html">Next</a></p>
        <p><a href="DispatchingARequest.html">Prev</a></p>
    </header>
    <section>
        <h1>Brighter</h1>
        <h2>Building a Pipeline of Request Handlers</h2>
        <p>Once you are using the features of Brighter to act as a <a href="CommandsCommandDispatcherandProcessor.html">command dispatcher</a>  and send or publish messages to a target handler,
         you may want to use its  <a href="CommandsCommandDispatcherandProcessor.html">command processor</a> features to handle orthogonal operations.</p>
       <p>Common examples of orthogonal operations include:</p>
        <ul>
            <li>Logging the Command</li>
            <li>Providing integration with tools for monitoring performance and availability</li>
            <li>Validating the Command</li>
            <li>Supporting idempotency of messages</li>
            <li>Supporting re-sequencing of messages</li>
            <li>Handling exceptions</li>
            <li><a href="QualityOfServicePatterns.html"> Providing Timeout, Retry, and Circuit Breaker support</a></li>
            <li>Providing undo support, or rollback</li>
        </ul>
        <h2>The Pipes and Filters Architectural Style</h2>
        <p>To handle these orthogonal concerns our <a href="CommandsCommandDispatcherandProcessor.html">command processor</a>
            uses a pipes and filters architectural style: the filters are where processing occurs, they do not share state
            with other filters, nor do they know about adjacent filters. The pipe is the connector between the filters
            in our case this is provided by the <strong>IHandleRequests&lt;TRequest&gt;</strong> interface which has
            a method <strong> IHandleRequests&ltTRequest&gt Successor</strong> that allows us to chain filters together.
        </p>
        <img src="images/PipesAndFilters.png">
        <p>The sink handler is handler that is the receiver you wish to invoke the action on. The pump is
            the <strong>Command Dispatcher</strong>. We occasionally use <em>target handler</em> as a synonym for
            <em>sink handler</em>
        </p>
         <h2>The Russian Doll Model</h2>
        <p>Our pipes and filters approach supports the <em>Russian Doll Model</em> of calling the handler pipeline,
            a context bag for the pipeline, and support fo generating a request path description out-of-the-box.
        </p>
        <p>The <em>Russian Doll Model</em> is names for the <a href="http://en.wikipedia.org/wiki/Matryoshka_doll">Matryoshka</a>
            wooden dolls, in which dolls of decreasing sizes are nested one inside another. The importance of this for
            a <a href="https://msdn.microsoft.com/en-us/library/dn589788.aspx">pipes and filters pattern</a> style is
            that each filter in the pipeline is called within the scope of a previous filter in the pipeline.
        </p>
        <img src="images/RussianDoll.png" height="318" width="318">
        <p> This is significant because you may desire to act before and after a subsequent filter step. One particular
            use case is exception handling: a try-catch block that wraps the call to a subsequent step can react to
            exceptions raised by subsequent steps. This allows us to create policy decisions around exceptions
            using a library such as <a href="https://github.com/michael-wolfenden/Polly">Polly</a> and thus
            support <a href="https://msdn.microsoft.com/en-us/library/dn589788.aspx">Retry</a>
            and <a href="https://msdn.microsoft.com/en-gb/library/dn589784.aspx?f=255&MSPPError=-2147217396">Circuit Breaker</a></p>
        <p>Our usage of the Russian Doll Model was inspired by <a href="http://codebetter.com/jeremymiller/2011/01/09/fubumvcs-internal-runtime-the-russian-doll-model-and-how-it-compares-to-asp-net-mvc-and-openrasta/">FubuMVC</a>
        </p>
        <h2>Implementing a Pipeline</h2>
        <p>The first step in building a pipeline is to decide that we want an orthogonal operation in our pipeline.
            Let us assume that we want to do basic request logging.</p>
        <p>Because you do not want to write an orthogonal handler for every Command or Event type,
            these handlers should remain generic types. At runtime the framework will request HandlerFactory
            creates an instance of the generic type specialized for the type parameter of the Command or Event
            being passed along the pipeline.
        </p>
        <p>The limitation here is that you can only make assumptions about the type you receive into the pipeline from
            the constraints on the generic type.
        </p>
         <p>Although it is possible to implement the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/IHandleRequests.cs">IHandleRequests</a>
            interface directly, we recommend deriving your handler from <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/RequestHandler.cs">RequestHandler&lt;T&gt;</a>.
         </p>
         <p>Let us assume that we want to log all requests travelling through the pipeline. (We provide this for you
             in the Paramore.Brighter.CommandProcessor packages so this for illustration only). We could implement a
             generic handler as follows:</p>
        <pre><code>
using System;
using Newtonsoft.Json;
using paramore.brighter.commandprocessor.Logging;

namespace paramore.brighter.commandprocessor
{
    public class RequestLoggingHandler&lt;TRequest&gt;
        : RequestHandler&lt;TRequest&gt; where TRequest : class, IRequest
    {
        private HandlerTiming _timing;

        public override void InitializeFromAttributeParams(
            params object[] initializerList
        )
        {
            _timing = (HandlerTiming)initializerList[0];
        }

        public override TRequest Handle(TRequest command)
        {
            LogCommand(command);
            return base.Handle(command);
        }

        private void LogCommand(TRequest request)
        {
            logger.InfoFormat(&quot;Logging handler pipeline call. Pipeline timing {0} target, for {1} with values of {2} at: {3}&quot;,
                _timing.ToString(),
                typeof(TRequest),
                JsonConvert.SerializeObject(request),
                DateTime.UtcNow);
        }
    }
}
        </code></pre>
        <p>Our Handle method is the method which will be called by the pipeline to service the request. After we log
            we call <strong>return base.Handle(command)</strong> to ensure that the next handler in the chain is called.
            If we failed to do this, the <em>target handler</em>  would not be called nor any subsequent handlers in the chain.
            This call to the next item in the chain is how we support the 'Russian Doll' model - because the next handler
            is called within the scope of this handler, we can manage when it is called handle exceptions, units of work,
            etc.
        </p>
        <p>It is worth remembering that handlers may be called after the target handler (in essence you can designate an
            orthogonal handler as the sink handler when configuring your pipeline). For this reason <strong>**all**</strong>
            handlers should remember to call their successor, <strong>even **your** target handler</strong>.
        </p>
        <p>We now need to tell our pipeline to call this orthogonal handler before our target handler. To do this we use
            attributes. The code we want to write looks like this:
        </p>
        <pre><code>
class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
{
    [RequestLogging(step: 1, timing: HandlerTiming.Before)]
    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return base.Handle(command);
    }
}
        </code></pre>
        <p>The <strong>RequestLogging</strong> Attribute tells the Command Processor to insert a Logging handler into the request handling pipeline before
            (<strong>HandlerTiming.Before</strong>) we run the target handler. It tells the Command Processor that we want it to be the first handler to run
            if we have multiple orthogonal handlers i.e. attributes (<strong>step: 1</strong>).
        </p>
        <p>We implement the <strong>RequestLoggingAttribute</strong> by creating our own Attribute class,
            derived from <strong>RequestHandlerAttribute</strong>.
        </p>
        <pre><code>
public class RequestLoggingAttribute : RequestHandlerAttribute
{
    public RequestLoggingAttribute(int step, HandlerTiming timing)
        : base(step, timing)
        { }

    public override object[] InitializerParams()
    {
        return new object[] { Timing };
    }

    public override Type GetHandlerType()
    {
        return typeof(RequestLoggingHandler&lt;&gt;);
    }
}
        </code></pre>
        <p>The most important part of this implementation is the GetHandlerType() method, where we return the type of our
            handler. At runtime the Command Processor uses reflection to determine what attributes are on the target handler and
            requests an instance of that type from the user-supplied <strong>Handler Factory</strong>.
        </p>
        <p>Your Handler Factory needs to respond to requests for instances of a <strong>RequestHandler&lt;T&gt;</strong>
            specialized for a concrete type. For example, if You create a<strong> RequestLoggingHandler&lt;TRequest&gt;</strong>
            we will ask you for a <strong>RequestLoggingHandler&lt;MyCommand&gt;</strong> etc. Depending on your implementation of
            HandlerFactory, you may need to register an implementation for every concrete instance of your handler with
            your underlying IoC container etc.
        </p>
        <p>Note that as we rely on an user supplied implementation of <strong>IAmAHandlerFactory</strong> to instantiate
            Handlers, you can have any dependencies in the constructor of your handler that you can resolve at runtime.
            In this case we pass in an ILog reference to actually log to.</p>
        <p>You may wish to pass parameter from your Attribute to the handler. Attributes can have constructor parameters
            or public members that you can set when adding the Attribute to a
            target method. These can only be compile time constants, see the documentation <a href="https://msdn.microsoft.com/en-us/library/aa664615%28v=vs.71%29.aspx">here</a>. After the Command Processor
            calls your Handler Factory to create an instance of your type it calls the <strong>RequestHandler.InitializeFromAttributeParams</strong>
            method on that created type and passes it the object array defined in the <strong>RequestHandlerAttribute.InitializerParams</strong>.
            By this approach, you can pass parameters to the handler, for example the Timing parameter is passed to the handler above.
        </p>
        <p>It is worth noting that you are limited when using Attributes to provide constructor values that are compile
            time constants, you cannot pass dynamic information. To put it another way you are limited to value set at
            design time not at run time.
        </p>
        <p>In fact, you can use this approach to pass any data to the handler on initialization, not just attribute
            constructor or property values, but you are constrained to what you can access from the context of the
            Attribute at run time. it can be tempting to set retrieve global state via the <a href="http://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a>
            pattern at this point. Avoid that temptation as it creates coupling between your Attribute and global state
            reducing modifiability.
        </p>
        <h2>Using a Manual Approach</h2>
        <p>Using an attribute based approach is not an approach favoured by everyone. Some people prefer a more explicit
            approach to configuring the pipeline.
        </p>
        <p>This is possible, we just don't provide any help out-of-the-box. Although see this
            <a href="https://github.com/iancooper/Paramore/issues/4">issue</a> for a placeholder to fix that.
        </p>
        <p>The trick is to remember that any handler that derives from <strong>IHandleRequests&lt;TRequest&gt;</strong>
            has a <strong>Successor</strong> and you can build a chain by having the first handler call
            the second handler's <strong>Handle()</strong> method i.e. <strong>Successor.Handle()</strong>.
            You can derive from <strong>RequestHandler&lt;T&gt;</strong> and call <strong>base.Handle()</strong>
            for this, even if you don't want to use the Attribute based pipelines.
        </p>
        <p>In the SubscriberRegistry you just register the first Handler in your pipeline. When we lookup the Handler
            for the Command in the SubscriberRegistry we will call it's Handle method. It
            can execute your code, and then call it's Successor (using the Russian Doll approach).
        </p>
        <pre><code>
        var myCommandHandler = new MyCommandHandler();
        var myLoggingHandler = new MyLoggingHandler(log);

        myLoggingHandler.Successor = myCommandHandler;

        var subscriberRegistry = new SubscriberRegistry();
        subscriberRegistry.Register&lt;MyCommand, MyLoggingHandler&gt;();
        </code></pre>
        <p>It is worth noting that as you control the HandlerFactory, you could also register the sink handler,
            but when instantiating an instance of it on request, build the pipeline of handlers yourself.</p>
        <p>We think it is easier to use attributes, but there may be circumstances where that approach does not work,
            and so this option is supported as well.</p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>