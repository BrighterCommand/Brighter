<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/BrighterCommand/Brighter">View the Project on GitHub <small>BrighterCommand/Brighter</small></a></p>
        <ul>
            <li><a href="https://github.com/BrighterCommand/Brighter/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Brighter/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Brighter">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="GreetingsExample.html">Next</a></p>
        <p><a href="Introduction.html">Prev</a></p>
    </header>
    <section>
        <h1>Brighter</h1>
        <h2>Tutorial</h2>
        <p>This tutorial takes you building a Hello World project. The walkthrough will build the example availabe in the Examples folder of Brighter
            available in the public repo at <a href="https://github.com/BrighterCommand/Brighter/tree/master/samples/HelloWorld">Hello World Example</a>
            if you want to follow along there instead of typing in the code.</p>
        <h3>Step One</h3>
        <p>Create a C# Console Application, targeting .NET 4.5. (Note that you can use any kind of host application, a console application is just the
            simplest way to get up and running in an example.</p>
        <img src="images/HelloWorld-Step1-ConsoleProject.png">
        <h3>Step Two</h3>
        <p>Install the <strong>Paramore.Brighter</strong> package from NuGet</p>
        <ul>
            <li>PM> Install-Package Paramore.Brighter</li>
        </ul>
        <img src="images/NuGet-Brighter.png">
        <h3>Step Three</h3>
        <p>Add the following code to the Main class:</p>
         <pre><code>
var registry = new SubscriberRegistry();

var builder = CommandProcessorBuilder.With()
    .Handlers(new HandlerConfiguration(
            subscriberRegistry: registry,
            handlerFactory: new SimpleHandlerFactory()
        ))
    .DefaultPolicy()
    .NoTaskQueues()
    .RequestContextFactory(new InMemoryRequestContextFactory());

var commandProcessor = builder.Build();
         </code></pre>
        <h4>Requests and Request Handlers</h4>
        <p>A <em>Command Dispatcher</em> works by looking up registered handlers for the command or event and forwarding the request to them, i.e. publish-subscribe.</p>
        <p>For this you need: to publish a Command or Event derived from <strong>IRequest</strong> and
            implement a subscribing handler that derives from <strong>IHandleRequests&lt;TRequest&gt;</strong> where TRequest is the type of Command or Event you are subscribing to.</p>
        <p>You use the <strong>SubscriberRegistry</strong> class to register those subscriptions. So for a command <em>GreetingCommand</em> we expect you to register a type derived
            from <em>IHandleRequests&lt;GreetingCommand&gt;</em>, let's call it <em>GreetingCommandHandler</em>, using the Register method on the SubscriberRegistry
            e.g. <em>subscriberRegistry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;()</em>.</p>
        <h4>Handler Factories</h4>
        <p>At runtime, when you send a message to Brighter, it builds a pipeline to handle requests. To do this it looks up all the handlers you just registered with the subscriber registry
            for your command or event.</p>
        <p>Once we have found one or more registered handlers for the type of the request we need to create instances of them.  This is complicated by your handler having its own dependencies
            which need to be created, which may have their own dependencies and so on.</p>
        <p>We don't know how to construct your handler so we call a factory, that you provide us, to build this entire
            dependency chain. This factory needs to implement the interface defined in <strong>IAmAHandlerFactory</strong>.</p>
        <p>Brighter manages the lifetimes of handlers, as we consider the request pipeline to be a scope, and we will call your factory again asking to release those handlers once we have terminated
            the pipeline and finished processing the request. You should take appropriate action to clear up the handler and its dependencies in response to that call</p>
        <p>It's worth reading Mark Seeman's article on <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI Friendly Frameworks</a> to understand this technique. Brighter originally
            used a conforming container but switched to user defined factories as per Mark's blog.</p>
        <h4>The Command Processor Builder</h4>
        <p>With this example creating an instance of the Command Processor is straightforward: as we provide a builder with a fluent interface to help you set up the builder. Because we ask
            you to provide factories where we need to create objects in your project, there are a number of items that you will need to configure. But you do this once, at the composition root,
            are then done with it.</p>
        <h4>Simple Handler Factory</h4>
        <p>In this case, the handler factory does not need to be implemented using an IoC container. We'll show that in a fuller example, but here it is trivial. For this simple program we just add
            this in the Program.cs file.</p>
        <pre><code>
internal class SimpleHandlerFactory : IAmAHandlerFactory
{
    public IHandleRequests Create(Type handlerType)
    {
        if (handlerType == typeof(GreetingCommandHandler))
            return new GreetingCommandHandler();    
        else
            return null; // Ignore other handler types for demo
    }

    public void Release(IHandleRequests handler)
    {
    }
}
        </code></pre>
        <p>When we create a command processor we need the registry of subscribers to message types, and the factory for creating those handlers, that we discussed above.</p>
        <p> Finally we want to give it a request context - a data structure passed to each handler in the chain, with global information including a property bag.
            Unless you have a need to override it, just use the default <strong>InMemoryRequestContextFactory</strong> to provide instances of a suitable context (overriding this is an advanced option
            - particularly useful for testing).</p>
        <p>Optionally we may include a registry of <a href="https://github.com/michael-wolfenden/Polly">Polly</a> policies,
            which you can use for Quality of Service issues (more elsewhere) and provide support for task queues - that is  handling work asynchronously by queuing it for later execution by one or
            or more worker processes). We do not need either here.</p>
        <h3>Step Four</h3>
        <h4>Our First Command</h4>
        <p>Now that you have a command processor, we want to create a message, and a handler for that message. We'll choose to implement a command, that in the finest tradition of demo applications
        just displays hello [name} on the console.</p>
        <p>Add a new class to the project called GreetingCommand and enter the following code:</p>
         <pre><code>
 class GreetingCommand : IRequest
 {
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
 }
         </code></pre>
        <h4>Our First Handler</h4>
        <p>Now that we have a Command we need to write a handler for it.</p>
        <p>We recommend using the RequestHandler abstract base class to implement your derived class from  <strong>IHandleRequests&lt;TRequest&gt;</strong> as it handles the basic responsibilities
        of a handler in the pipeline.</p>
        <p> Add a new class to the project called GreetingCommandHandler and then enter the following code:</p>
         <pre><code>
 class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
 {
    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return base.Handle(command);
    }
 }
         </code></pre>
        <p>You could directly implement the base class, but as we provide useful functionality to make sure that your handler participates in the handler pipeline correctly you
            should derive from this class unless you have a compelling reason to implement that support yourself.</p>
        <p>As each handler participates in the chain it is expected that you will return the input you were given, the command or event, so that the next handler in the chain
            can also process the request. We call the base class Handle() method at the end, as this calls the next handler in the pipeline for you, if there is one. In this case
            there is no handler, so you could get away with just returning the Command argument, but calling the base method is a good habit to form, as it allows you to later chain together
            handlers.</p>
        <p>In a 'real' application you would load your domain model's state from persistent storage here, process the request using your domain model and then save the
        state of the domain model. See <a href="CommandsCommandDispatcherandProcessor.html">Commands, Command Dispatcher and Processor</a> for more on this idiom.</p>
        <h3>Step Four</h3>
        <p>Having created a handler we have to tell Brighter about it. So we need to add it to the subscriber registry, we added above. Modify the code in Main as follows:</p>
        <pre><code>
var registry = new SubscriberRegistry();
registry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;();
        </code></pre>
        <p>We also need to tell the handler factory how to build an instance of this class on request. We go for a simple implementation here, just to get up and running. This
        is obviously not production code. replace the TODO in the Handler Factory above with the following code</p>
        <pre><code>
public IHandleRequests Create(Type handlerType)
{
    return new GreetingCommandHandler();
}
        </code></pre>
        <h3>Step Five</h3>
        <p>Now that we have a handler registered, it is time to send it a message. The command processor exposes a send for point-to-point messaging (usually a command would have one
        handler), and publish for broadcast to zero or more handlers (usually an event has zero or more handlers)</p>
        <pre><code>
commandProcessor.Send(new GreetingCommand("Ian"));
        </code></pre>
        <h3>Step Six</h3>
        <p>let's just review the code. It's not a fine example of software development, but it serves to show you how Brighter works without any fuss</p>
        <pre><code>
class Program
{
    static void Main(string[] args)
    {
        var registry = new SubscriberRegistry();
        registry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;();

        var builder = CommandProcessorBuilder.With()
            .Handlers(new HandlerConfiguration(
                    subscriberRegistry: registry,
                    handlerFactory: new SimpleHandlerFactory()
                ))
            .DefaultPolicy()
            .NoTaskQueues()
            .RequestContextFactory(new InMemoryRequestContextFactory());

        var commandProcessor = builder.Build();

        commandProcessor.Send(new GreetingCommand("Ian"));
    }

    internal class SimpleHandlerFactory : IAmAHandlerFactory
    {
        public IHandleRequests Create(Type handlerType)
        {
            if (handlerType == typeof(GreetingCommandHandler))
                return new GreetingCommandHandler();    
            else
                return null; // Ignore other handler types for demo
        }

        public void Release(IHandleRequests handler)
        {
        }
    }
}

class GreetingCommand : IRequest
{
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
}

class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
{
    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return base.Handle(command);
    }
}
        </code></pre>
        <h3>Step Seven</h3>
        <p>Now just build and run. You should see your greeting pumped out to the console.</p>
        <h3>Next Steps</h3>
        <p>That is a brief introduction in how to get a command processor working. We explore how to work with a Task Queue in the <a href="GreetingsExample.html">Greetings Example</a></p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>
