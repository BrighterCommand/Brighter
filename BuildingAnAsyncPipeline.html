<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="Monitoring.html">Next</a></p>
        <p><a href="ImplementingAsyncHandler.html">Prev</a></p>
    </header>
    <section>
        <h1>Brighter</h1>
        <h2>Building a Pipeline of Async Request Handlers</h2>
        <p>Once you are using the features of Brighter to act as a <a href="CommandsCommandDispatcherandProcessor.html">command dispatcher</a>
            and send or publish messages to a target handler, you may want to use its
            <a href="CommandsCommandDispatcherandProcessor.html">command processor</a> features to handle orthogonal operations.
        </p>
        <h2>Implementing a Pipeline</h2>
        <p>The first step in building a pipeline is to decide that we want an orthogonal operation in our pipeline.
            Let us assume that we want to do command sourcing.
        </p>
        <p>Because you do not want to write an orthogonal handler for every Command or Event type, these handlers should
            remain generic types. At runtime the framework will request HandlerFactory creates an instance
            of the generic type specialized for the type parameter of the Command or Event being passed along the pipeline.
        </p>
        <p>The limitation here is that you can only make assumptions about the type you receive into the  pipeline from
            the constraints on the generic type.
        </p>
        <p>Although it is possible to implement the <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/IHandleRequestsAsync.cs">IHandleRequestsAsync</a>
            interface directly, we recommend deriving your handler from <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/RequestHandlerAsync.cs">RequestHandlerAsync&lt;T&gt;</a>.
        </p>
        <p>Let us assume that we want to log all requests travelling through the pipeline. (We provide this for you in
            the Paramore.Brighter.CommandProcessor packages so this for illustration only). We could
            implement a generic handler as follows:</p>
<pre><code>
public class CommandSourcingHandlerAsync&lt;T&gt; : RequestHandlerAsync&lt;T&gt; where T : class, IRequest
{
    private readonly IAmACommandStoreAsync _commandStore;

    public CommandSourcingHandlerAsync(IAmACommandStoreAsync commandStore)
        : this(commandStore, LogProvider.GetCurrentClassLogger())
    { }


    public CommandSourcingHandlerAsync(IAmACommandStoreAsync commandStore, ILog logger) : base(logger)
    {
        _commandStore = commandStore;
    }

    public override async Task&lt;T&gt; HandleAsync(T command, CancellationToken? ct = null)
    {
        logger.DebugFormat("Writing command {0} to the Command Store", command.Id);

        await _commandStore.AddAsync(command, -1, ct).ConfigureAwait(ContinueOnCapturedContext);

        return await base.HandleAsync(command, ct).ConfigureAwait(ContinueOnCapturedContext);
    }
}
</code></pre>
        <p>Our HandleAsync method is the method which will be called by the pipeline to service the request. After we log we
            call <strong>return await base.HandleAsync(command, ct)</strong> to ensure that the next handler in the chain
            is called.
        </p>
        <p>If we failed to do this, the <em>target handler</em> would not be called nor any subsequent handlers in the chain.
            This call to the next item in the chain is how we support the 'Russian Doll' model - because the next handler
            is called within the scope of this handler, we can manage when it is called handle exceptions, units of work,
            etc.
        </p>
        <p>It is worth remembering that handlers may be called after the target handler (in essence you can designate an
            orthogonal handler as the sink handler when configuring your pipeline). For this reason <strong>**all**</strong>
            handlers should remember to call their successor, <strong>even **your** target handler</strong>.
        </p>
        <p>We now need to tell our pipeline to call this orthogonal handler before our target handler. To do this we use
            attributes. The code we want to write looks like this:
        </p>
<pre><code>
internal class GreetingCommandRequestHandlerAsync : RequestHandlerAsync&lt;GreetingCommand&gt;
{
    [UseCommandSourcingAsync(step: 1, timing: HandlerTiming.Before)]
    public override async Task&lt;GreetingCommand&gt; HandleAsync(GreetingCommand command, CancellationToken? ct = null)
    {
        var api = new IpFyApi(new Uri("https://api.ipify.org"));

        var result = await api.GetAsync(ct);

        Console.WriteLine("Hello {0}", command.Name);
        Console.WriteLine(result.Success ? "Your public IP addres is {0}" : "Call to IpFy API failed : {0}", result.Message);
        return await base.HandleAsync(command, ct).ConfigureAwait(base.ContinueOnCapturedContext);
    }
}
</code></pre>
        <p>The <strong>UseCommandSourcingAsync</strong> Attribute tells the Command Processor to insert a Logging handler into
            the request handling pipeline before(<strong>HandlerTiming.Before</strong>) we run the target handler. It
            tells the Command Processor that we want it to be the first handler to run
            if we have multiple orthogonal handlers i.e. attributes (<strong>step: 1</strong>).
        </p>
        <p>We implement the <strong>UseCommandSourcingAsyncAttribute</strong> by creating our own Attribute class, derived from
            <strong>RequestHandlerAttribute</strong>.
        </p>
<pre><code>
public class UseCommandSourcingAsyncAttribute : RequestHandlerAttribute
{

    public UseCommandSourcingAsyncAttribute(int step, HandlerTiming timing = HandlerTiming.Before)
        : base(step, timing)
    { }


    public override Type GetHandlerType()
    {
        return typeof (CommandSourcingHandlerAsync<>);
    }
}
</code></pre>
        <p>The most important part of this implementation is the GetHandlerType() method, where we return the type of
            our handler. At runtime the Command Processor uses reflection to determine what attributes are on the target
            handler and requests an instance of that type from the user-supplied <strong>Handler Factory</strong>.
        </p>
        <p>Your Handler Factory needs to respond to requests for instances of a <strong>RequestHandlerAsync&lt;T&gt;</strong>
            specialized for a concrete type. For example, if you create a<strong>CommandSourcingHandlerAsync&lt;TRequest&gt;</strong>
            we will ask you for a <strong>CommandSourcingHandlerAsync&lt;MyCommand&gt;</strong> etc. Depending on your implementation of
            HandlerFactory, you may need to register an implementation for every concrete instance of your handler with
            your underlying IoC container etc.
        </p>
        <p>Note that as we rely on an user supplied implementation of <strong>IAmAHandlerFactory</strong> to instantiate
            Handlers, you can have any dependencies in the constructor of your handler that you can resolve at runtime.
            In this case we pass in an ILog reference to actually log to.
        </p>
        <p>You may wish to pass parameter from your Attribute to the handler. Attributes can have constructor parameters
            or public members that you can set when adding the Attribute to a target method. These can only be compile
            time constants, see the documentation <a href="https://msdn.microsoft.com/en-us/library/aa664615%28v=vs.71%29.aspx">here</a>.
            After the Command Processor calls your Handler Factory to create an instance of your type it calls the
            <strong>RequestHandler.InitializeFromAttributeParams</strong> method on that created type and passes it the
            object array defined in the <strong>RequestHandlerAttribute.InitializerParams</strong>. By this approach,
            you can pass parameters to the handler, for example the Timing parameter is passed to the handler above.
        </p>
        <p>It is worth noting that you are limited when using Attributes to provide constructor values that are compile
            time constants, you cannot pass dynamic information. To put it another
            way you are limited to value set at design time not at run time.
        </p>
        <p>In fact, you can use this approach to pass any data to the handler on initialization, not just attribute constructor
            or property values, but you are constrained to what you can access from the
            context of the Attribute at run time. It can be tempting to set retrieve global state via
            the <a href="http://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a> pattern at this point.
            Avoid that temptation as it creates coupling between your Attribute and global state reducing modifiability.
        </p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>
