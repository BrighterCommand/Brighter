<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Libraries and supporting examples for use with the Ports and Adapters and CQRS architectural styles for .NET, with support for Task Queues</p>
        <p class="view"><a href="https://github.com/BrighterCommand/Paramore.Brighter">View the Project on GitHub <small>BrighterCommand/Paramore.Brighter</small></a></p>
        <ul>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/BrighterCommand/Paramore.Brighter">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="../index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
        <p><a href="BuildingAnAsyncPipeline.html">Next</a></p>
        <p><a href="AsyncDispatchARequest.html">Prev</a></p>
    </header>
    <section>
        <h1>Brighter</h1>
        <h2>How to Implement an Asynchronous Request Handler</h2>
        <p>To implement an asynchronous handler, derive from <strong>RequestHandlerAsync&lt;T&gt;</strong> where <em>T</em>
            should be the <strong>Command</strong> or <strong>Event</strong> derived type that you wish to handle. Then
            override the base class <strong>RequestHandlerAsync&lt;T&gt;.HandleAsync()</strong> method to implement your
            handling for the Command or Event.
        </p>
        <p>For example, assume that you want to handle the <strong>Command</strong> GreetingCommand</p>
        <pre><code>
class GreetingCommand : IRequest
{
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
}
        </code></pre>
        <p>Then derive your handler from <strong>RequestHandlerAsync&lt;GreetingCommand&gt;</strong> and accept a parameter of that type
            on the overriden <strong>HandleAsync()</strong> method, along with a nullable cancellation token - which you should default to
            null.
        </p>
        <p>To ensure that the pipeline runs, you should return the result of the next handler in the chain, by awaiting
            the base class <strong>HandleAsync()</strong>.
        </p>
        <P>(Because the next element in the pipeline should also be async, you should always await the result of this call.)</P>
        <pre><code>
class GreetingCommandRequestHandlerAsync : RequestHandlerAsync<GreetingCommand>
{
    public override async Task<GreetingCommand> HandleAsync(GreetingCommand command, CancellationToken? ct = null)
    {
        var api = new IpFyApi(new Uri("https://api.ipify.org"));

        var result = await api.GetAsync(ct);

        Console.WriteLine("Hello {0}", command.Name);
        Console.WriteLine(result.Success ? "Your public IP addres is {0}" : "Call to IpFy API failed : {0}",
        result.Message);
        return await base.HandleAsync(command, ct).ConfigureAwait(base.ContinueOnCapturedContext);
    }
}
</code></pre>
    <p>Note how we use <strong>ConfigureAwait()</strong> when calling the next handler in the chain, and set the value
        to the <strong>RequestHandlerAsync&lt;GreetingCommand&gt;.ContinueOnCapturedContext</strong> property. This
        ensures that we utilize any override of the default (which is to use the Task Scheduler) made when the call to
        <strong>SendAsync</strong>, <strong>PublishAsync</strong>, or <strong>PostAsync</strong> was made.
    </p>
    <p>It is worth noting that although the override forces you to return a <strong>Task&lt;T&gt;</strong> it does not
        force you to add the <strong>async</strong> keyword to the method to compile. This risks introducing a subtle bug. You can await
        a method that returns a <strong>Task&lt;T&gt;</strong> but creation of the state machine in the caller depends
        on the presence of the <strong>async</strong> keyword. If your handler does not await anything, you will not be forced to add the
        <strong>async</strong> keyword. Your handler will run sychronously in this context, which may not be what you expect.
    </p>
    <p>Remembering to always await the base class <strong>HandleAsync()</strong> mitigates against this as even if your
        handler does not do asynchronous work, you will be forced to add <strong>async</strong> to the signature.
    </p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>